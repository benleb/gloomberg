// Package cmd provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen/v2 version v2.1.0 DO NOT EDIT.
package cmd

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	OpenSeaAuthScopes = "OpenSeaAuth.Scopes"
)

// Defines values for CancelEventModelEventTypeEnum.
const (
	CancelEventModelEventTypeEnumCancel CancelEventModelEventTypeEnum = "cancel"
)

// Defines values for CategoryType.
const (
	CategoryTypeNumber CategoryType = "number"
	CategoryTypeString CategoryType = "string"
)

// Defines values for CollectionStatsInterval.
const (
	OneDay   CollectionStatsInterval = "one_day"
	OneMonth CollectionStatsInterval = "one_month"
	OneWeek  CollectionStatsInterval = "one_week"
)

// Defines values for ConfigEnum.
const (
	Affiliate            ConfigEnum = "affiliate"
	AffiliateBlacklisted ConfigEnum = "affiliate_blacklisted"
	AffiliatePartner     ConfigEnum = "affiliate_partner"
	AffiliateRequested   ConfigEnum = "affiliate_requested"
	Employee             ConfigEnum = "employee"
	Moderator            ConfigEnum = "moderator"
	Staff                ConfigEnum = "staff"
	Verified             ConfigEnum = "verified"
)

// Defines values for CreatedAtEnum.
const (
	Empty CreatedAtEnum = " "
)

// Defines values for DisplayTypeField.
const (
	DisplayTypeFieldAuthor          DisplayTypeField = "author"
	DisplayTypeFieldBoostNumber     DisplayTypeField = "boost_number"
	DisplayTypeFieldBoostPercentage DisplayTypeField = "boost_percentage"
	DisplayTypeFieldDate            DisplayTypeField = "date"
	DisplayTypeFieldNone            DisplayTypeField = "None"
	DisplayTypeFieldNumber          DisplayTypeField = "number"
)

// Defines values for ItemType.
const (
	ItemTypeN0 ItemType = 0
	ItemTypeN1 ItemType = 1
	ItemTypeN2 ItemType = 2
	ItemTypeN3 ItemType = 3
	ItemTypeN4 ItemType = 4
	ItemTypeN5 ItemType = 5
)

// Defines values for OrderEventModelEventTypeEnum.
const (
	OrderEventModelEventTypeEnumOrder OrderEventModelEventTypeEnum = "order"
)

// Defines values for OrderTypeEnum.
const (
	OrderTypeEnumBasic    OrderTypeEnum = "basic"
	OrderTypeEnumCriteria OrderTypeEnum = "criteria"
	OrderTypeEnumDutch    OrderTypeEnum = "dutch"
	OrderTypeEnumEnglish  OrderTypeEnum = "english"
)

// Defines values for RedemptionEventModelEventTypeEnum.
const (
	RedemptionEventModelEventTypeEnumRedemption RedemptionEventModelEventTypeEnum = "redemption"
)

// Defines values for SaleEventModelEventTypeEnum.
const (
	Sale SaleEventModelEventTypeEnum = "sale"
)

// Defines values for TransferEventModelEventTypeEnum.
const (
	Transfer TransferEventModelEventTypeEnum = "transfer"
)

// Defines values for CoreBlockchainEvmAbiModelsSeaportOrderType.
const (
	CoreBlockchainEvmAbiModelsSeaportOrderTypeN0 CoreBlockchainEvmAbiModelsSeaportOrderType = 0
	CoreBlockchainEvmAbiModelsSeaportOrderTypeN1 CoreBlockchainEvmAbiModelsSeaportOrderType = 1
	CoreBlockchainEvmAbiModelsSeaportOrderTypeN2 CoreBlockchainEvmAbiModelsSeaportOrderType = 2
	CoreBlockchainEvmAbiModelsSeaportOrderTypeN3 CoreBlockchainEvmAbiModelsSeaportOrderType = 3
	CoreBlockchainEvmAbiModelsSeaportOrderTypeN4 CoreBlockchainEvmAbiModelsSeaportOrderType = 4
)

// Defines values for ListNftsByAccountParamsChain.
const (
	ListNftsByAccountParamsChainArbitrum       ListNftsByAccountParamsChain = "arbitrum"
	ListNftsByAccountParamsChainArbitrumGoerli ListNftsByAccountParamsChain = "arbitrum_goerli"
	ListNftsByAccountParamsChainArbitrumNova   ListNftsByAccountParamsChain = "arbitrum_nova"
	ListNftsByAccountParamsChainAvalanche      ListNftsByAccountParamsChain = "avalanche"
	ListNftsByAccountParamsChainAvalancheFuji  ListNftsByAccountParamsChain = "avalanche_fuji"
	ListNftsByAccountParamsChainBaobab         ListNftsByAccountParamsChain = "baobab"
	ListNftsByAccountParamsChainBase           ListNftsByAccountParamsChain = "base"
	ListNftsByAccountParamsChainBaseGoerli     ListNftsByAccountParamsChain = "base_goerli"
	ListNftsByAccountParamsChainBsc            ListNftsByAccountParamsChain = "bsc"
	ListNftsByAccountParamsChainBsctestnet     ListNftsByAccountParamsChain = "bsctestnet"
	ListNftsByAccountParamsChainEthereum       ListNftsByAccountParamsChain = "ethereum"
	ListNftsByAccountParamsChainGoerli         ListNftsByAccountParamsChain = "goerli"
	ListNftsByAccountParamsChainKlaytn         ListNftsByAccountParamsChain = "klaytn"
	ListNftsByAccountParamsChainMatic          ListNftsByAccountParamsChain = "matic"
	ListNftsByAccountParamsChainMumbai         ListNftsByAccountParamsChain = "mumbai"
	ListNftsByAccountParamsChainOptimism       ListNftsByAccountParamsChain = "optimism"
	ListNftsByAccountParamsChainOptimismGoerli ListNftsByAccountParamsChain = "optimism_goerli"
	ListNftsByAccountParamsChainSepolia        ListNftsByAccountParamsChain = "sepolia"
	ListNftsByAccountParamsChainSolana         ListNftsByAccountParamsChain = "solana"
	ListNftsByAccountParamsChainSoldev         ListNftsByAccountParamsChain = "soldev"
	ListNftsByAccountParamsChainZora           ListNftsByAccountParamsChain = "zora"
	ListNftsByAccountParamsChainZoraTestnet    ListNftsByAccountParamsChain = "zora_testnet"
)

// Defines values for GetContractParamsChain.
const (
	GetContractParamsChainArbitrum       GetContractParamsChain = "arbitrum"
	GetContractParamsChainArbitrumGoerli GetContractParamsChain = "arbitrum_goerli"
	GetContractParamsChainArbitrumNova   GetContractParamsChain = "arbitrum_nova"
	GetContractParamsChainAvalanche      GetContractParamsChain = "avalanche"
	GetContractParamsChainAvalancheFuji  GetContractParamsChain = "avalanche_fuji"
	GetContractParamsChainBaobab         GetContractParamsChain = "baobab"
	GetContractParamsChainBase           GetContractParamsChain = "base"
	GetContractParamsChainBaseGoerli     GetContractParamsChain = "base_goerli"
	GetContractParamsChainBsc            GetContractParamsChain = "bsc"
	GetContractParamsChainBsctestnet     GetContractParamsChain = "bsctestnet"
	GetContractParamsChainEthereum       GetContractParamsChain = "ethereum"
	GetContractParamsChainGoerli         GetContractParamsChain = "goerli"
	GetContractParamsChainKlaytn         GetContractParamsChain = "klaytn"
	GetContractParamsChainMatic          GetContractParamsChain = "matic"
	GetContractParamsChainMumbai         GetContractParamsChain = "mumbai"
	GetContractParamsChainOptimism       GetContractParamsChain = "optimism"
	GetContractParamsChainOptimismGoerli GetContractParamsChain = "optimism_goerli"
	GetContractParamsChainSepolia        GetContractParamsChain = "sepolia"
	GetContractParamsChainSolana         GetContractParamsChain = "solana"
	GetContractParamsChainSoldev         GetContractParamsChain = "soldev"
	GetContractParamsChainZora           GetContractParamsChain = "zora"
	GetContractParamsChainZoraTestnet    GetContractParamsChain = "zora_testnet"
)

// Defines values for ListNftsByContractParamsChain.
const (
	ListNftsByContractParamsChainArbitrum       ListNftsByContractParamsChain = "arbitrum"
	ListNftsByContractParamsChainArbitrumGoerli ListNftsByContractParamsChain = "arbitrum_goerli"
	ListNftsByContractParamsChainArbitrumNova   ListNftsByContractParamsChain = "arbitrum_nova"
	ListNftsByContractParamsChainAvalanche      ListNftsByContractParamsChain = "avalanche"
	ListNftsByContractParamsChainAvalancheFuji  ListNftsByContractParamsChain = "avalanche_fuji"
	ListNftsByContractParamsChainBaobab         ListNftsByContractParamsChain = "baobab"
	ListNftsByContractParamsChainBase           ListNftsByContractParamsChain = "base"
	ListNftsByContractParamsChainBaseGoerli     ListNftsByContractParamsChain = "base_goerli"
	ListNftsByContractParamsChainBsc            ListNftsByContractParamsChain = "bsc"
	ListNftsByContractParamsChainBsctestnet     ListNftsByContractParamsChain = "bsctestnet"
	ListNftsByContractParamsChainEthereum       ListNftsByContractParamsChain = "ethereum"
	ListNftsByContractParamsChainGoerli         ListNftsByContractParamsChain = "goerli"
	ListNftsByContractParamsChainKlaytn         ListNftsByContractParamsChain = "klaytn"
	ListNftsByContractParamsChainMatic          ListNftsByContractParamsChain = "matic"
	ListNftsByContractParamsChainMumbai         ListNftsByContractParamsChain = "mumbai"
	ListNftsByContractParamsChainOptimism       ListNftsByContractParamsChain = "optimism"
	ListNftsByContractParamsChainOptimismGoerli ListNftsByContractParamsChain = "optimism_goerli"
	ListNftsByContractParamsChainSepolia        ListNftsByContractParamsChain = "sepolia"
	ListNftsByContractParamsChainSolana         ListNftsByContractParamsChain = "solana"
	ListNftsByContractParamsChainSoldev         ListNftsByContractParamsChain = "soldev"
	ListNftsByContractParamsChainZora           ListNftsByContractParamsChain = "zora"
	ListNftsByContractParamsChainZoraTestnet    ListNftsByContractParamsChain = "zora_testnet"
)

// Defines values for GetNftParamsChain.
const (
	GetNftParamsChainArbitrum       GetNftParamsChain = "arbitrum"
	GetNftParamsChainArbitrumGoerli GetNftParamsChain = "arbitrum_goerli"
	GetNftParamsChainArbitrumNova   GetNftParamsChain = "arbitrum_nova"
	GetNftParamsChainAvalanche      GetNftParamsChain = "avalanche"
	GetNftParamsChainAvalancheFuji  GetNftParamsChain = "avalanche_fuji"
	GetNftParamsChainBaobab         GetNftParamsChain = "baobab"
	GetNftParamsChainBase           GetNftParamsChain = "base"
	GetNftParamsChainBaseGoerli     GetNftParamsChain = "base_goerli"
	GetNftParamsChainBsc            GetNftParamsChain = "bsc"
	GetNftParamsChainBsctestnet     GetNftParamsChain = "bsctestnet"
	GetNftParamsChainEthereum       GetNftParamsChain = "ethereum"
	GetNftParamsChainGoerli         GetNftParamsChain = "goerli"
	GetNftParamsChainKlaytn         GetNftParamsChain = "klaytn"
	GetNftParamsChainMatic          GetNftParamsChain = "matic"
	GetNftParamsChainMumbai         GetNftParamsChain = "mumbai"
	GetNftParamsChainOptimism       GetNftParamsChain = "optimism"
	GetNftParamsChainOptimismGoerli GetNftParamsChain = "optimism_goerli"
	GetNftParamsChainSepolia        GetNftParamsChain = "sepolia"
	GetNftParamsChainSolana         GetNftParamsChain = "solana"
	GetNftParamsChainSoldev         GetNftParamsChain = "soldev"
	GetNftParamsChainZora           GetNftParamsChain = "zora"
	GetNftParamsChainZoraTestnet    GetNftParamsChain = "zora_testnet"
)

// Defines values for RefreshNftParamsChain.
const (
	RefreshNftParamsChainArbitrum       RefreshNftParamsChain = "arbitrum"
	RefreshNftParamsChainArbitrumGoerli RefreshNftParamsChain = "arbitrum_goerli"
	RefreshNftParamsChainArbitrumNova   RefreshNftParamsChain = "arbitrum_nova"
	RefreshNftParamsChainAvalanche      RefreshNftParamsChain = "avalanche"
	RefreshNftParamsChainAvalancheFuji  RefreshNftParamsChain = "avalanche_fuji"
	RefreshNftParamsChainBaobab         RefreshNftParamsChain = "baobab"
	RefreshNftParamsChainBase           RefreshNftParamsChain = "base"
	RefreshNftParamsChainBaseGoerli     RefreshNftParamsChain = "base_goerli"
	RefreshNftParamsChainBsc            RefreshNftParamsChain = "bsc"
	RefreshNftParamsChainBsctestnet     RefreshNftParamsChain = "bsctestnet"
	RefreshNftParamsChainEthereum       RefreshNftParamsChain = "ethereum"
	RefreshNftParamsChainGoerli         RefreshNftParamsChain = "goerli"
	RefreshNftParamsChainKlaytn         RefreshNftParamsChain = "klaytn"
	RefreshNftParamsChainMatic          RefreshNftParamsChain = "matic"
	RefreshNftParamsChainMumbai         RefreshNftParamsChain = "mumbai"
	RefreshNftParamsChainOptimism       RefreshNftParamsChain = "optimism"
	RefreshNftParamsChainOptimismGoerli RefreshNftParamsChain = "optimism_goerli"
	RefreshNftParamsChainSepolia        RefreshNftParamsChain = "sepolia"
	RefreshNftParamsChainSolana         RefreshNftParamsChain = "solana"
	RefreshNftParamsChainSoldev         RefreshNftParamsChain = "soldev"
	RefreshNftParamsChainZora           RefreshNftParamsChain = "zora"
	RefreshNftParamsChainZoraTestnet    RefreshNftParamsChain = "zora_testnet"
)

// Defines values for ListEventsByAccountParamsChain.
const (
	ListEventsByAccountParamsChainArbitrum       ListEventsByAccountParamsChain = "arbitrum"
	ListEventsByAccountParamsChainArbitrumGoerli ListEventsByAccountParamsChain = "arbitrum_goerli"
	ListEventsByAccountParamsChainArbitrumNova   ListEventsByAccountParamsChain = "arbitrum_nova"
	ListEventsByAccountParamsChainAvalanche      ListEventsByAccountParamsChain = "avalanche"
	ListEventsByAccountParamsChainAvalancheFuji  ListEventsByAccountParamsChain = "avalanche_fuji"
	ListEventsByAccountParamsChainBaobab         ListEventsByAccountParamsChain = "baobab"
	ListEventsByAccountParamsChainBase           ListEventsByAccountParamsChain = "base"
	ListEventsByAccountParamsChainBaseGoerli     ListEventsByAccountParamsChain = "base_goerli"
	ListEventsByAccountParamsChainBsc            ListEventsByAccountParamsChain = "bsc"
	ListEventsByAccountParamsChainBsctestnet     ListEventsByAccountParamsChain = "bsctestnet"
	ListEventsByAccountParamsChainEthereum       ListEventsByAccountParamsChain = "ethereum"
	ListEventsByAccountParamsChainGoerli         ListEventsByAccountParamsChain = "goerli"
	ListEventsByAccountParamsChainKlaytn         ListEventsByAccountParamsChain = "klaytn"
	ListEventsByAccountParamsChainMatic          ListEventsByAccountParamsChain = "matic"
	ListEventsByAccountParamsChainMumbai         ListEventsByAccountParamsChain = "mumbai"
	ListEventsByAccountParamsChainOptimism       ListEventsByAccountParamsChain = "optimism"
	ListEventsByAccountParamsChainOptimismGoerli ListEventsByAccountParamsChain = "optimism_goerli"
	ListEventsByAccountParamsChainSepolia        ListEventsByAccountParamsChain = "sepolia"
	ListEventsByAccountParamsChainSolana         ListEventsByAccountParamsChain = "solana"
	ListEventsByAccountParamsChainSoldev         ListEventsByAccountParamsChain = "soldev"
	ListEventsByAccountParamsChainZora           ListEventsByAccountParamsChain = "zora"
	ListEventsByAccountParamsChainZoraTestnet    ListEventsByAccountParamsChain = "zora_testnet"
)

// Defines values for ListEventsByAccountParamsEventType.
const (
	ListEventsByAccountParamsEventTypeAll        ListEventsByAccountParamsEventType = "all"
	ListEventsByAccountParamsEventTypeCancel     ListEventsByAccountParamsEventType = "cancel"
	ListEventsByAccountParamsEventTypeOrder      ListEventsByAccountParamsEventType = "order"
	ListEventsByAccountParamsEventTypeRedemption ListEventsByAccountParamsEventType = "redemption"
	ListEventsByAccountParamsEventTypeSale       ListEventsByAccountParamsEventType = "sale"
	ListEventsByAccountParamsEventTypeTransfer   ListEventsByAccountParamsEventType = "transfer"
)

// Defines values for ListEventsByNftParamsEventType.
const (
	ListEventsByNftParamsEventTypeAll        ListEventsByNftParamsEventType = "all"
	ListEventsByNftParamsEventTypeCancel     ListEventsByNftParamsEventType = "cancel"
	ListEventsByNftParamsEventTypeOrder      ListEventsByNftParamsEventType = "order"
	ListEventsByNftParamsEventTypeRedemption ListEventsByNftParamsEventType = "redemption"
	ListEventsByNftParamsEventTypeSale       ListEventsByNftParamsEventType = "sale"
	ListEventsByNftParamsEventTypeTransfer   ListEventsByNftParamsEventType = "transfer"
)

// Defines values for ListEventsByNftParamsChain.
const (
	ListEventsByNftParamsChainArbitrum       ListEventsByNftParamsChain = "arbitrum"
	ListEventsByNftParamsChainArbitrumGoerli ListEventsByNftParamsChain = "arbitrum_goerli"
	ListEventsByNftParamsChainArbitrumNova   ListEventsByNftParamsChain = "arbitrum_nova"
	ListEventsByNftParamsChainAvalanche      ListEventsByNftParamsChain = "avalanche"
	ListEventsByNftParamsChainAvalancheFuji  ListEventsByNftParamsChain = "avalanche_fuji"
	ListEventsByNftParamsChainBaobab         ListEventsByNftParamsChain = "baobab"
	ListEventsByNftParamsChainBase           ListEventsByNftParamsChain = "base"
	ListEventsByNftParamsChainBaseGoerli     ListEventsByNftParamsChain = "base_goerli"
	ListEventsByNftParamsChainBsc            ListEventsByNftParamsChain = "bsc"
	ListEventsByNftParamsChainBsctestnet     ListEventsByNftParamsChain = "bsctestnet"
	ListEventsByNftParamsChainEthereum       ListEventsByNftParamsChain = "ethereum"
	ListEventsByNftParamsChainGoerli         ListEventsByNftParamsChain = "goerli"
	ListEventsByNftParamsChainKlaytn         ListEventsByNftParamsChain = "klaytn"
	ListEventsByNftParamsChainMatic          ListEventsByNftParamsChain = "matic"
	ListEventsByNftParamsChainMumbai         ListEventsByNftParamsChain = "mumbai"
	ListEventsByNftParamsChainOptimism       ListEventsByNftParamsChain = "optimism"
	ListEventsByNftParamsChainOptimismGoerli ListEventsByNftParamsChain = "optimism_goerli"
	ListEventsByNftParamsChainSepolia        ListEventsByNftParamsChain = "sepolia"
	ListEventsByNftParamsChainSolana         ListEventsByNftParamsChain = "solana"
	ListEventsByNftParamsChainSoldev         ListEventsByNftParamsChain = "soldev"
	ListEventsByNftParamsChainZora           ListEventsByNftParamsChain = "zora"
	ListEventsByNftParamsChainZoraTestnet    ListEventsByNftParamsChain = "zora_testnet"
)

// Defines values for ListEventsByCollectionParamsEventType.
const (
	ListEventsByCollectionParamsEventTypeAll        ListEventsByCollectionParamsEventType = "all"
	ListEventsByCollectionParamsEventTypeCancel     ListEventsByCollectionParamsEventType = "cancel"
	ListEventsByCollectionParamsEventTypeOrder      ListEventsByCollectionParamsEventType = "order"
	ListEventsByCollectionParamsEventTypeRedemption ListEventsByCollectionParamsEventType = "redemption"
	ListEventsByCollectionParamsEventTypeSale       ListEventsByCollectionParamsEventType = "sale"
	ListEventsByCollectionParamsEventTypeTransfer   ListEventsByCollectionParamsEventType = "transfer"
)

// Defines values for GetOrderParamsChain.
const (
	GetOrderParamsChainArbitrum       GetOrderParamsChain = "arbitrum"
	GetOrderParamsChainArbitrumGoerli GetOrderParamsChain = "arbitrum_goerli"
	GetOrderParamsChainArbitrumNova   GetOrderParamsChain = "arbitrum_nova"
	GetOrderParamsChainAvalanche      GetOrderParamsChain = "avalanche"
	GetOrderParamsChainAvalancheFuji  GetOrderParamsChain = "avalanche_fuji"
	GetOrderParamsChainBaobab         GetOrderParamsChain = "baobab"
	GetOrderParamsChainBase           GetOrderParamsChain = "base"
	GetOrderParamsChainBaseGoerli     GetOrderParamsChain = "base_goerli"
	GetOrderParamsChainBsc            GetOrderParamsChain = "bsc"
	GetOrderParamsChainBsctestnet     GetOrderParamsChain = "bsctestnet"
	GetOrderParamsChainEthereum       GetOrderParamsChain = "ethereum"
	GetOrderParamsChainGoerli         GetOrderParamsChain = "goerli"
	GetOrderParamsChainKlaytn         GetOrderParamsChain = "klaytn"
	GetOrderParamsChainMatic          GetOrderParamsChain = "matic"
	GetOrderParamsChainMumbai         GetOrderParamsChain = "mumbai"
	GetOrderParamsChainOptimism       GetOrderParamsChain = "optimism"
	GetOrderParamsChainOptimismGoerli GetOrderParamsChain = "optimism_goerli"
	GetOrderParamsChainSepolia        GetOrderParamsChain = "sepolia"
	GetOrderParamsChainSolana         GetOrderParamsChain = "solana"
	GetOrderParamsChainSoldev         GetOrderParamsChain = "soldev"
	GetOrderParamsChainZora           GetOrderParamsChain = "zora"
	GetOrderParamsChainZoraTestnet    GetOrderParamsChain = "zora_testnet"
)

// Defines values for GetOrderParamsProtocolAddress.
const (
	X00000000000000adc04c56bf30ac9d3c0aaf14dc GetOrderParamsProtocolAddress = "[0x00000000000000adc04c56bf30ac9d3c0aaf14dc]"
)

// Defines values for GetListingsParamsOrderBy.
const (
	GetListingsParamsOrderByCreatedDate GetListingsParamsOrderBy = "created_date"
	GetListingsParamsOrderByEthPrice    GetListingsParamsOrderBy = "eth_price"
)

// Defines values for GetListingsParamsOrderDirection.
const (
	GetListingsParamsOrderDirectionAsc  GetListingsParamsOrderDirection = "asc"
	GetListingsParamsOrderDirectionDesc GetListingsParamsOrderDirection = "desc"
)

// Defines values for GetListingsParamsChain.
const (
	GetListingsParamsChainArbitrum       GetListingsParamsChain = "arbitrum"
	GetListingsParamsChainArbitrumGoerli GetListingsParamsChain = "arbitrum_goerli"
	GetListingsParamsChainArbitrumNova   GetListingsParamsChain = "arbitrum_nova"
	GetListingsParamsChainAvalanche      GetListingsParamsChain = "avalanche"
	GetListingsParamsChainAvalancheFuji  GetListingsParamsChain = "avalanche_fuji"
	GetListingsParamsChainBaobab         GetListingsParamsChain = "baobab"
	GetListingsParamsChainBase           GetListingsParamsChain = "base"
	GetListingsParamsChainBaseGoerli     GetListingsParamsChain = "base_goerli"
	GetListingsParamsChainBsc            GetListingsParamsChain = "bsc"
	GetListingsParamsChainBsctestnet     GetListingsParamsChain = "bsctestnet"
	GetListingsParamsChainEthereum       GetListingsParamsChain = "ethereum"
	GetListingsParamsChainGoerli         GetListingsParamsChain = "goerli"
	GetListingsParamsChainKlaytn         GetListingsParamsChain = "klaytn"
	GetListingsParamsChainMatic          GetListingsParamsChain = "matic"
	GetListingsParamsChainMumbai         GetListingsParamsChain = "mumbai"
	GetListingsParamsChainOptimism       GetListingsParamsChain = "optimism"
	GetListingsParamsChainOptimismGoerli GetListingsParamsChain = "optimism_goerli"
	GetListingsParamsChainSepolia        GetListingsParamsChain = "sepolia"
	GetListingsParamsChainSolana         GetListingsParamsChain = "solana"
	GetListingsParamsChainSoldev         GetListingsParamsChain = "soldev"
	GetListingsParamsChainZora           GetListingsParamsChain = "zora"
	GetListingsParamsChainZoraTestnet    GetListingsParamsChain = "zora_testnet"
)

// Defines values for GetListingsParamsProtocol.
const (
	GetListingsParamsProtocolSeaport GetListingsParamsProtocol = "seaport"
)

// Defines values for PostListingParamsChain.
const (
	PostListingParamsChainArbitrum       PostListingParamsChain = "arbitrum"
	PostListingParamsChainArbitrumGoerli PostListingParamsChain = "arbitrum_goerli"
	PostListingParamsChainArbitrumNova   PostListingParamsChain = "arbitrum_nova"
	PostListingParamsChainAvalanche      PostListingParamsChain = "avalanche"
	PostListingParamsChainAvalancheFuji  PostListingParamsChain = "avalanche_fuji"
	PostListingParamsChainBaobab         PostListingParamsChain = "baobab"
	PostListingParamsChainBase           PostListingParamsChain = "base"
	PostListingParamsChainBaseGoerli     PostListingParamsChain = "base_goerli"
	PostListingParamsChainBsc            PostListingParamsChain = "bsc"
	PostListingParamsChainBsctestnet     PostListingParamsChain = "bsctestnet"
	PostListingParamsChainEthereum       PostListingParamsChain = "ethereum"
	PostListingParamsChainGoerli         PostListingParamsChain = "goerli"
	PostListingParamsChainKlaytn         PostListingParamsChain = "klaytn"
	PostListingParamsChainMatic          PostListingParamsChain = "matic"
	PostListingParamsChainMumbai         PostListingParamsChain = "mumbai"
	PostListingParamsChainOptimism       PostListingParamsChain = "optimism"
	PostListingParamsChainOptimismGoerli PostListingParamsChain = "optimism_goerli"
	PostListingParamsChainSepolia        PostListingParamsChain = "sepolia"
	PostListingParamsChainSolana         PostListingParamsChain = "solana"
	PostListingParamsChainSoldev         PostListingParamsChain = "soldev"
	PostListingParamsChainZora           PostListingParamsChain = "zora"
	PostListingParamsChainZoraTestnet    PostListingParamsChain = "zora_testnet"
)

// Defines values for PostListingParamsProtocol.
const (
	PostListingParamsProtocolSeaport PostListingParamsProtocol = "seaport"
)

// Defines values for GetOffersParamsOrderBy.
const (
	GetOffersParamsOrderByCreatedDate GetOffersParamsOrderBy = "created_date"
	GetOffersParamsOrderByEthPrice    GetOffersParamsOrderBy = "eth_price"
)

// Defines values for GetOffersParamsOrderDirection.
const (
	GetOffersParamsOrderDirectionAsc  GetOffersParamsOrderDirection = "asc"
	GetOffersParamsOrderDirectionDesc GetOffersParamsOrderDirection = "desc"
)

// Defines values for GetOffersParamsChain.
const (
	GetOffersParamsChainArbitrum       GetOffersParamsChain = "arbitrum"
	GetOffersParamsChainArbitrumGoerli GetOffersParamsChain = "arbitrum_goerli"
	GetOffersParamsChainArbitrumNova   GetOffersParamsChain = "arbitrum_nova"
	GetOffersParamsChainAvalanche      GetOffersParamsChain = "avalanche"
	GetOffersParamsChainAvalancheFuji  GetOffersParamsChain = "avalanche_fuji"
	GetOffersParamsChainBaobab         GetOffersParamsChain = "baobab"
	GetOffersParamsChainBase           GetOffersParamsChain = "base"
	GetOffersParamsChainBaseGoerli     GetOffersParamsChain = "base_goerli"
	GetOffersParamsChainBsc            GetOffersParamsChain = "bsc"
	GetOffersParamsChainBsctestnet     GetOffersParamsChain = "bsctestnet"
	GetOffersParamsChainEthereum       GetOffersParamsChain = "ethereum"
	GetOffersParamsChainGoerli         GetOffersParamsChain = "goerli"
	GetOffersParamsChainKlaytn         GetOffersParamsChain = "klaytn"
	GetOffersParamsChainMatic          GetOffersParamsChain = "matic"
	GetOffersParamsChainMumbai         GetOffersParamsChain = "mumbai"
	GetOffersParamsChainOptimism       GetOffersParamsChain = "optimism"
	GetOffersParamsChainOptimismGoerli GetOffersParamsChain = "optimism_goerli"
	GetOffersParamsChainSepolia        GetOffersParamsChain = "sepolia"
	GetOffersParamsChainSolana         GetOffersParamsChain = "solana"
	GetOffersParamsChainSoldev         GetOffersParamsChain = "soldev"
	GetOffersParamsChainZora           GetOffersParamsChain = "zora"
	GetOffersParamsChainZoraTestnet    GetOffersParamsChain = "zora_testnet"
)

// Defines values for GetOffersParamsProtocol.
const (
	GetOffersParamsProtocolSeaport GetOffersParamsProtocol = "seaport"
)

// Defines values for PostOfferParamsChain.
const (
	PostOfferParamsChainArbitrum       PostOfferParamsChain = "arbitrum"
	PostOfferParamsChainArbitrumGoerli PostOfferParamsChain = "arbitrum_goerli"
	PostOfferParamsChainArbitrumNova   PostOfferParamsChain = "arbitrum_nova"
	PostOfferParamsChainAvalanche      PostOfferParamsChain = "avalanche"
	PostOfferParamsChainAvalancheFuji  PostOfferParamsChain = "avalanche_fuji"
	PostOfferParamsChainBaobab         PostOfferParamsChain = "baobab"
	PostOfferParamsChainBase           PostOfferParamsChain = "base"
	PostOfferParamsChainBaseGoerli     PostOfferParamsChain = "base_goerli"
	PostOfferParamsChainBsc            PostOfferParamsChain = "bsc"
	PostOfferParamsChainBsctestnet     PostOfferParamsChain = "bsctestnet"
	PostOfferParamsChainEthereum       PostOfferParamsChain = "ethereum"
	PostOfferParamsChainGoerli         PostOfferParamsChain = "goerli"
	PostOfferParamsChainKlaytn         PostOfferParamsChain = "klaytn"
	PostOfferParamsChainMatic          PostOfferParamsChain = "matic"
	PostOfferParamsChainMumbai         PostOfferParamsChain = "mumbai"
	PostOfferParamsChainOptimism       PostOfferParamsChain = "optimism"
	PostOfferParamsChainOptimismGoerli PostOfferParamsChain = "optimism_goerli"
	PostOfferParamsChainSepolia        PostOfferParamsChain = "sepolia"
	PostOfferParamsChainSolana         PostOfferParamsChain = "solana"
	PostOfferParamsChainSoldev         PostOfferParamsChain = "soldev"
	PostOfferParamsChainZora           PostOfferParamsChain = "zora"
	PostOfferParamsChainZoraTestnet    PostOfferParamsChain = "zora_testnet"
)

// Defines values for PostOfferParamsProtocol.
const (
	PostOfferParamsProtocolSeaport PostOfferParamsProtocol = "seaport"
)

// BasicListingPrice defines model for BasicListingPrice.
type BasicListingPrice struct {
	Current PriceModel `json:"current"`
}

// BuildOffer defines model for BuildOffer.
type BuildOffer struct {
	// EncodedTokenIds Represents a list of token ids which can be used to fulfill the criteria offer. When decoded using the provided SDK function, developers can now see a list of all tokens that could be used to fulfill the offer.
	EncodedTokenIds *string `json:"encoded_token_ids,omitempty"`

	// PartialParameters Partial set of Seaport Order Parameters
	PartialParameters PartialParameters `json:"partialParameters"`
}

// BuildOfferInput defines model for BuildOfferInput.
type BuildOfferInput struct {
	// Criteria Criteria for the collection or trait offer
	Criteria Criteria `json:"criteria"`

	// OfferProtectionEnabled Builds the offer on OpenSea's signed zone to provide offer protections from receiving an item which is disabled from trading.
	OfferProtectionEnabled *bool `json:"offer_protection_enabled,omitempty"`

	// Offerer The address which supplies all the items in the offer.
	Offerer string `json:"offerer"`

	// ProtocolAddress Exchange contract address. Must be one of ['0x00000000000000adc04c56bf30ac9d3c0aaf14dc']
	ProtocolAddress string `json:"protocol_address"`

	// Quantity The number of offers to place.
	Quantity *int `json:"quantity,omitempty"`
}

// CancelEventModel defines model for CancelEventModel.
type CancelEventModel struct {
	// Chain The chain on which the cancelled order originated
	Chain     ChainIdentifier                `json:"chain"`
	EventType *CancelEventModelEventTypeEnum `json:"event_type,omitempty"`

	// OrderHash Order hash for the order which was cancelled
	OrderHash string `json:"order_hash"`
}

// CancelEventModelEventTypeEnum defines model for CancelEventModelEventTypeEnum.
type CancelEventModelEventTypeEnum string

// CategoryType An enumeration.
type CategoryType string

// ChainIdentifier OpenSea supported chains.
type ChainIdentifier = interface{}

// Collection defines model for Collection.
type Collection struct {
	// Slug Unique string to identify a collection on OpenSea. This can be found by visiting the collection on the OpenSea website and noting the last path parameter.
	Slug string `json:"slug"`
}

// CollectionContractModel Define the Contract's Addresses and Chain
type CollectionContractModel struct {
	// Address The unique public blockchain identifier, address, for the contract.
	Address string `json:"address"`

	// Chain The chain on which the contract exists
	Chain ChainIdentifier `json:"chain"`
}

// CollectionFeeModel defines model for CollectionFeeModel.
type CollectionFeeModel struct {
	// Fee Percentage of the sale price that is paid to the recipient
	Fee float32 `json:"fee"`

	// Recipient The unique public blockchain identifier, address, for the recipient
	Recipient string `json:"recipient"`

	// Required If the fee is required for the collection
	Required *bool `json:"required,omitempty"`
}

// CollectionModel defines model for CollectionModel.
type CollectionModel struct {
	// Category Category of the collection (e.g. PFPs, Memberships, Art)
	Category string `json:"category"`

	// Collection Collection slug. A unique string to identify a collection on OpenSea
	Collection string                    `json:"collection"`
	Contracts  []CollectionContractModel `json:"contracts"`

	// Description Description of the collection
	Description *string `json:"description,omitempty"`

	// DiscordUrl External URL for the collection's Discord server
	DiscordUrl *string `json:"discord_url,omitempty"`

	// InstagramUsername Username for the collection's Instagram account
	InstagramUsername *string `json:"instagram_username,omitempty"`

	// IsDisabled If the collection is currently able to be bought or sold using OpenSea
	IsDisabled bool `json:"is_disabled"`

	// IsNsfw If the collection is currently classified as 'Not Safe for Work' by OpenSea
	IsNsfw bool `json:"is_nsfw"`

	// Name Name of the collection
	Name string `json:"name"`

	// OpenseaUrl OpenSea Link to collection
	OpenseaUrl string `json:"opensea_url"`

	// Owner The unique public blockchain identifier, address, for the owner wallet.
	Owner string `json:"owner"`

	// ProjectUrl External URL for the collection's website
	ProjectUrl *string `json:"project_url,omitempty"`

	// SafelistStatus Status of the collection verification requests.
	SafelistStatus SafelistRequestStatus `json:"safelist_status"`

	// TelegramUrl External URL for the collection's Telegram group
	TelegramUrl *string `json:"telegram_url,omitempty"`

	// TraitOffersEnabled If trait offers are currently being accepted for the collection
	TraitOffersEnabled bool `json:"trait_offers_enabled"`

	// TwitterUsername Username for the collection's Twitter account
	TwitterUsername *string `json:"twitter_username,omitempty"`

	// WikiUrl External URL for the collection's wiki
	WikiUrl *string `json:"wiki_url,omitempty"`
}

// CollectionStatsInterval The interval for which the stats are calculated
type CollectionStatsInterval string

// CollectionStatsIntervalModel defines model for CollectionStatsIntervalModel.
type CollectionStatsIntervalModel struct {
	// AveragePrice The average sale price of NFTs in the collection during the interval
	AveragePrice float32 `json:"average_price"`

	// Interval The interval for which the stats are calculated
	Interval CollectionStatsInterval `json:"interval"`

	// Sales The number of sales for the collection during the specified interval
	Sales int `json:"sales"`

	// SalesDiff The percentage change in number of sales compared to the previous interval
	SalesDiff float32 `json:"sales_diff"`

	// Volume The volume of sales for the collection during the specified interval
	Volume float32 `json:"volume"`

	// VolumeChange The percentage change in volume compared to the previous interval
	VolumeChange float32 `json:"volume_change"`

	// VolumeDiff The volume differential compared to the previous interval
	VolumeDiff float32 `json:"volume_diff"`
}

// CollectionStatsModel defines model for CollectionStatsModel.
type CollectionStatsModel struct {
	// AveragePrice The all time average sale price of NFTs in the collection
	AveragePrice float32 `json:"average_price"`

	// FloorPrice The current lowest price of NFTs in the collection
	FloorPrice float32 `json:"floor_price"`

	// FloorPriceSymbol The symbol of the payment asset for the floor price
	FloorPriceSymbol string `json:"floor_price_symbol"`

	// MarketCap The current market cap of the collection
	MarketCap float32 `json:"market_cap"`

	// NumOwners The current number of unique owners of NFTs in the collection
	NumOwners int `json:"num_owners"`

	// Sales The all time number of sales for the collection
	Sales int `json:"sales"`

	// Volume The all time volume of sales for the collection
	Volume float32 `json:"volume"`
}

// ConfigEnum * `affiliate` - affiliate
// * `affiliate_partner` - affiliate_partner
// * `affiliate_requested` - affiliate_requested
// * `affiliate_blacklisted` - affiliate_blacklisted
// * `verified` - verified
// * `moderator` - moderator
// * `staff` - staff
// * `employee` - employee
type ConfigEnum string

// ConsiderationInput defines model for ConsiderationInput.
type ConsiderationInput struct {
	AssetContractAddress string `json:"asset_contract_address"`

	// TokenId NFT Token ID which will be used to fulfill the offer.
	TokenId string `json:"token_id"`
}

// ConsiderationItem defines model for ConsiderationItem.
type ConsiderationItem struct {
	// EndAmount When endAmount differs from `startAmount`, the realized amount is calculated linearly based on the time elapsed since the order became active.
	EndAmount int `json:"endAmount"`

	// IdentifierOrCriteria The ERC721 or ERC1155 token identifier or, in the case of a criteria-based item type, a merkle root composed of the valid set of token identifiers for the item. This value will be ignored for Ether and ERC20 item types, and can optionally be zero for criteria-based item types to allow for any identifier.
	IdentifierOrCriteria int `json:"identifierOrCriteria"`

	// ItemType 0 - Native - Ether (or other native token for the given chain)
	// 1 - ERC20
	// 2 - ERC721
	// 3 - ERC1155
	// 4 - ERC721 with criteria
	// 5 - ERC1155 with criteria
	ItemType ItemType `json:"itemType"`

	// Recipient The address which will receive the consideration item when the order is executed.
	Recipient string `json:"recipient"`

	// StartAmount The amount of the token in question that will be required should the order be fulfilled.
	StartAmount int `json:"startAmount"`

	// Token The item's token contract (with the null address used for native tokens)
	Token string `json:"token"`
}

// Contract defines model for Contract.
type Contract struct {
	Address string `json:"address"`
}

// CreateListingResponse defines model for CreateListingResponse.
type CreateListingResponse struct {
	// Order OpenSea Order Object
	Order SignedSimpleOrderV2 `json:"order"`
}

// CreateOfferResponse defines model for CreateOfferResponse.
type CreateOfferResponse struct {
	// Order OpenSea Order Object
	Order SignedSimpleOrderV2 `json:"order"`
}

// CreatedAtEnum defines model for CreatedAtEnum.
type CreatedAtEnum string

// Criteria defines model for Criteria.
type Criteria struct {
	// Collection The collection in which the criteria offer is being made for.
	Collection Collection `json:"collection"`

	// Contract The unique public blockchain identifier, address, for the NFT contract
	Contract Contract `json:"contract"`

	// EncodedTokenIds Represents a list of token ids which can be used to fulfill the criteria offer. When decoded using the provided SDK function, developers can now see a list of all tokens that could be used to fulfill the offer.
	EncodedTokenIds *string `json:"encoded_token_ids,omitempty"`

	// Trait The trait that the criteria offer is being made for.
	Trait *Trait `json:"trait,omitempty"`
}

// DetailedAccountDataModel defines model for DetailedAccountDataModel.
type DetailedAccountDataModel struct {
	// Address The unique public blockchain identifier for the wallet.
	Address *string `json:"address,omitempty"`

	// BannerImageUrl The OpenSea account's banner url.
	BannerImageUrl *string `json:"banner_image_url,omitempty"`

	// Bio The OpenSea account's bio.
	Bio *string `json:"bio,omitempty"`

	// JoinedDate Date the account was first added to OpenSea.
	JoinedDate *openapi_types.Date `json:"joined_date,omitempty"`

	// ProfileImageUrl The OpenSea account's image url.
	ProfileImageUrl     *string                    `json:"profile_image_url,omitempty"`
	SocialMediaAccounts *[]SocialMediaAccountModel `json:"social_media_accounts,omitempty"`

	// Username The OpenSea account's username.
	Username *string `json:"username,omitempty"`

	// Website Personal website for the OpenSea user.
	Website *string `json:"website,omitempty"`
}

// DetailedCollectionModel defines model for DetailedCollectionModel.
type DetailedCollectionModel struct {
	// Category Category of the collection (e.g. PFPs, Memberships, Art)
	Category string `json:"category"`

	// Collection Collection slug. A unique string to identify a collection on OpenSea
	Collection string                    `json:"collection"`
	Contracts  []CollectionContractModel `json:"contracts"`

	// Description Description of the collection
	Description *string `json:"description,omitempty"`

	// DiscordUrl External URL for the collection's Discord server
	DiscordUrl *string `json:"discord_url,omitempty"`

	// Editors List of editor addresses for the collection
	Editors []string `json:"editors"`

	// Fees List of fees for the collection including creator earnings and OpenSea fees
	Fees []CollectionFeeModel `json:"fees"`

	// InstagramUsername Username for the collection's Instagram account
	InstagramUsername *string `json:"instagram_username,omitempty"`

	// IsDisabled If the collection is currently able to be bought or sold using OpenSea
	IsDisabled bool `json:"is_disabled"`

	// IsNsfw If the collection is currently classified as 'Not Safe for Work' by OpenSea
	IsNsfw bool `json:"is_nsfw"`

	// Name Name of the collection
	Name string `json:"name"`

	// OpenseaUrl OpenSea Link to collection
	OpenseaUrl string `json:"opensea_url"`

	// Owner The unique public blockchain identifier, address, for the owner wallet.
	Owner string `json:"owner"`

	// ProjectUrl External URL for the collection's website
	ProjectUrl *string `json:"project_url,omitempty"`

	// SafelistStatus Status of the collection verification requests.
	SafelistStatus SafelistRequestStatus `json:"safelist_status"`

	// TelegramUrl External URL for the collection's Telegram group
	TelegramUrl *string `json:"telegram_url,omitempty"`

	// TraitOffersEnabled If trait offers are currently being accepted for the collection
	TraitOffersEnabled bool `json:"trait_offers_enabled"`

	// TwitterUsername Username for the collection's Twitter account
	TwitterUsername *string `json:"twitter_username,omitempty"`

	// WikiUrl External URL for the collection's wiki
	WikiUrl *string `json:"wiki_url,omitempty"`
}

// DetailedNftModel defines model for DetailedNftModel.
type DetailedNftModel struct {
	// AnimationUrl Link to the NFT's original animation.
	AnimationUrl *string `json:"animation_url,omitempty"`

	// Collection Collection slug. A unique string to identify a collection on OpenSea
	Collection string `json:"collection"`

	// Contract The unique public blockchain identifier for the contract
	Contract string `json:"contract"`

	// CreatedAt Deprecated Field
	CreatedAt *CreatedAtEnum `json:"created_at,omitempty"`

	// Creator The unique public blockchain identifier, wallet address, for the creator
	Creator string `json:"creator"`

	// Description Description of the NFT
	Description string `json:"description"`

	// Identifier The NFT's unique identifier within the smart contract (also referred to as token_id)
	Identifier string `json:"identifier"`

	// ImageUrl Link to the NFT's original image. This may be an HTTP url, SVG data, or other directly embedded data.
	ImageUrl *string `json:"image_url,omitempty"`

	// IsDisabled If the item is currently able to be bought or sold using OpenSea
	IsDisabled bool `json:"is_disabled"`

	// IsNsfw If the item is currently classified as 'Not Safe for Work' by OpenSea
	IsNsfw bool `json:"is_nsfw"`

	// IsSuspicious If the item has been reported for suspicious activity by OpenSea
	IsSuspicious bool `json:"is_suspicious"`

	// MetadataUrl Link to the offchain metadata store
	MetadataUrl *string `json:"metadata_url,omitempty"`

	// Name Name of the NFT
	Name string `json:"name"`

	// Owners List of Owners. The field will be null if the NFT has more than 50 owners
	Owners []OwnerModel `json:"owners"`

	// Rarity Rarity data for the NFT
	Rarity RarityDataModel `json:"rarity"`

	// TokenStandard ERC standard of the token (erc721, erc1155)
	TokenStandard string `json:"token_standard"`

	// Traits List of Trait objects. The field will be null if the NFT has more than 50 traits
	Traits []TraitModel `json:"traits"`

	// UpdatedAt Last time that the NFT's metadata was updated by OpenSea
	UpdatedAt string `json:"updated_at"`
}

// DisplayTypeField A field indicating how to display. None is used for string traits.
type DisplayTypeField string

// EventPaymentModel defines model for EventPaymentModel.
type EventPaymentModel struct {
	// Decimals Returns the number of decimals the token uses - e.g. 8, means to divide the token amount by 100000000 to get its user representation.
	Decimals int `json:"decimals"`

	// Quantity Amount of tokens in the order
	Quantity int `json:"quantity"`

	// Symbol Returns the symbol of the token, e.g. ETH, WETH, USDC, etc
	Symbol string `json:"symbol"`

	// TokenAddress The contract address for the ERC20 token
	TokenAddress string `json:"token_address"`
}

// FulfillerInput defines model for FulfillerInput.
type FulfillerInput struct {
	Address string `json:"address"`
}

// FulfillmentData defines model for FulfillmentData.
type FulfillmentData struct {
	// Orders Array of Seaport Orders.
	Orders []SerializedOrder `json:"orders"`

	// Transaction The name of the fulfillment method and associated call data.
	Transaction Transaction `json:"transaction"`
}

// FulfillmentInput defines model for FulfillmentInput.
type FulfillmentInput struct {
	Chain string `json:"chain"`

	// Hash Hash of the order to fulfill.
	Hash string `json:"hash"`

	// ProtocolAddress Exchange contract address. Must be one of ['0x00000000000000adc04c56bf30ac9d3c0aaf14dc']
	ProtocolAddress *string `json:"protocol_address,omitempty"`
}

// FulfillmentOutput defines model for FulfillmentOutput.
type FulfillmentOutput struct {
	// FulfillmentData All the information, including signatures, needed to fulfill an order directly onchain.
	FulfillmentData FulfillmentData `json:"fulfillment_data"`

	// Protocol Exchange contract address. Must be one of ['0x00000000000000adc04c56bf30ac9d3c0aaf14dc']
	Protocol string `json:"protocol"`
}

// GenerateListingFulfillmentInput defines model for GenerateListingFulfillmentInput.
type GenerateListingFulfillmentInput struct {
	// Fulfiller Fulfiller address.
	Fulfiller FulfillerInput `json:"fulfiller"`

	// Listing Listing to get fullfillment data for.
	Listing FulfillmentInput `json:"listing"`
}

// GenerateOfferFulfillmentInput defines model for GenerateOfferFulfillmentInput.
type GenerateOfferFulfillmentInput struct {
	// Consideration If the offer you are fulfilling is a criteria offer, the NFT you are using to fulfill the offer with. The fulfiller account must own this NFT or the request will not succeed.
	Consideration *ConsiderationInput `json:"consideration,omitempty"`

	// Fulfiller Fulfiller address.
	Fulfiller FulfillerInput `json:"fulfiller"`

	// Offer Offer to get fullfillment data for.
	Offer FulfillmentInput `json:"offer"`
}

// GetCollectionStatsResponse defines model for GetCollectionStatsResponse.
type GetCollectionStatsResponse struct {
	// Intervals The stats for each interval
	Intervals []CollectionStatsIntervalModel `json:"intervals"`

	// Total The aggregate stats over the collection's lifetime
	Total CollectionStatsModel `json:"total"`
}

// GetListingsResponse defines model for GetListingsResponse.
type GetListingsResponse struct {
	// Next The cursor for the next page of results.
	Next   string    `json:"next"`
	Orders []OrderV2 `json:"orders"`

	// Previous The cursor for the previous page of results.
	Previous string `json:"previous"`
}

// GetNftResponse defines model for GetNftResponse.
type GetNftResponse struct {
	Nft DetailedNftModel `json:"nft"`
}

// GetOfferResponse defines model for GetOfferResponse.
type GetOfferResponse struct {
	// Next The cursor for the next page of results.
	Next   string    `json:"next"`
	Orders []OrderV2 `json:"orders"`

	// Previous The cursor for the previous page of results.
	Previous string `json:"previous"`
}

// GetOrderResult defines model for GetOrderResult.
type GetOrderResult struct {
	Order GetOrderResult_Order `json:"order"`
}

// GetOrderResult_Order defines model for GetOrderResult.Order.
type GetOrderResult_Order struct {
	union json.RawMessage
}

// GetTraitResponse defines model for GetTraitResponse.
type GetTraitResponse struct {
	// Categories List of trait categories, e.g. Background, in the collection and their type, e.g. string
	Categories *map[string]CategoryType `json:"categories,omitempty"`

	// Counts If the category type is STRING, the dict will contain each trait value and its count. Otherwise, the dict will contain the min and max value seen in the collection
	Counts *map[string]map[string]int `json:"counts,omitempty"`
}

// ItemType 0 - Native - Ether (or other native token for the given chain)
// 1 - ERC20
// 2 - ERC721
// 3 - ERC1155
// 4 - ERC721 with criteria
// 5 - ERC1155 with criteria
type ItemType int

// ListCollectionsResponse defines model for ListCollectionsResponse.
type ListCollectionsResponse struct {
	Collections []CollectionModel `json:"collections"`

	// Next Cursor for the next page of results
	Next string `json:"next"`
}

// ListEventsResponse defines model for ListEventsResponse.
type ListEventsResponse struct {
	AssetEvents []ListEventsResponse_AssetEvents_Item `json:"asset_events"`

	// Next Cursor for the next page of results
	Next string `json:"next"`
}

// ListEventsResponse_AssetEvents_Item defines model for ListEventsResponse.asset_events.Item.
type ListEventsResponse_AssetEvents_Item struct {
	union json.RawMessage
}

// ListNftsResponse defines model for ListNftsResponse.
type ListNftsResponse struct {
	// Next Cursor for the next page of results
	Next string     `json:"next"`
	Nfts []NftModel `json:"nfts"`
}

// Listing defines model for Listing.
type Listing struct {
	// Chain Chain the listing is on.
	Chain ChainIdentifier `json:"chain"`

	// OrderHash Order hash
	OrderHash string            `json:"order_hash"`
	Price     BasicListingPrice `json:"price"`

	// ProtocolAddress Exchange contract address
	ProtocolAddress string `json:"protocol_address"`

	// ProtocolData The onchain order data.
	ProtocolData SerializedOrder `json:"protocol_data"`

	// Type basic - Quantities are fixed. Used for fixed price listings and offers.
	// dutch - The quantity represents the starting price.
	// english - The quantity represents the minimum price.
	// criteria - The items that are accepted by this offer will be found in the criteria fields.
	Type CoreTypesOrderType `json:"type"`
}

// NftModel defines model for NftModel.
type NftModel struct {
	// Collection Collection slug. A unique string to identify a collection on OpenSea
	Collection string `json:"collection"`

	// Contract The unique public blockchain identifier for the contract
	Contract string `json:"contract"`

	// CreatedAt Deprecated Field
	CreatedAt *CreatedAtEnum `json:"created_at,omitempty"`

	// Description Description of the NFT
	Description string `json:"description"`

	// Identifier The NFT's unique identifier within the smart contract (also referred to as token_id)
	Identifier string `json:"identifier"`

	// ImageUrl Link to the image associated with the NFT
	ImageUrl *string `json:"image_url,omitempty"`

	// IsDisabled If the item is currently able to be bought or sold using OpenSea
	IsDisabled bool `json:"is_disabled"`

	// IsNsfw If the item is currently classified as 'Not Safe for Work' by OpenSea
	IsNsfw bool `json:"is_nsfw"`

	// MetadataUrl Link to the offchain metadata store
	MetadataUrl *string `json:"metadata_url,omitempty"`

	// Name Name of the NFT
	Name string `json:"name"`

	// TokenStandard ERC standard of the token (erc721, erc1155)
	TokenStandard string `json:"token_standard"`

	// UpdatedAt Last time that the NFT's metadata was updated by OpenSea
	UpdatedAt string `json:"updated_at"`
}

// Offer defines model for Offer.
type Offer struct {
	// Chain OpenSea supported chains.
	Chain ChainIdentifier `json:"chain"`

	// Criteria Criteria for collection or trait offers
	Criteria *Criteria `json:"criteria,omitempty"`

	// OrderHash Order hash
	OrderHash string `json:"order_hash"`

	// ProtocolAddress Exchange contract address
	ProtocolAddress string `json:"protocol_address"`

	// ProtocolData The onchain order data.
	ProtocolData SerializedOrder `json:"protocol_data"`
}

// OfferItem defines model for OfferItem.
type OfferItem struct {
	// EndAmount When endAmount differs from `startAmount`, the realized amount is calculated linearly based on the time elapsed since the order became active.
	EndAmount int `json:"endAmount"`

	// IdentifierOrCriteria The ERC721 or ERC1155 token identifier or, in the case of a criteria-based item type, a merkle root composed of the valid set of token identifiers for the item. This value will be ignored for Ether and ERC20 item types, and can optionally be zero for criteria-based item types to allow for any identifier.
	IdentifierOrCriteria int `json:"identifierOrCriteria"`

	// ItemType 0 - Native - Ether (or other native token for the given chain)
	// 1 - ERC20
	// 2 - ERC721
	// 3 - ERC1155
	// 4 - ERC721 with criteria
	// 5 - ERC1155 with criteria
	ItemType ItemType `json:"itemType"`

	// StartAmount The amount of the token in question that will be required should the order be fulfilled.
	StartAmount int `json:"startAmount"`

	// Token The item's token contract (with the null address used for native tokens)
	Token string `json:"token"`
}

// OfferList defines model for OfferList.
type OfferList struct {
	Offers []Offer `json:"offers"`
}

// OrderEventModel defines model for OrderEventModel.
type OrderEventModel struct {
	// Asset The asset being listed or bid on. Empty object for collection or trait offers.
	Asset OrderEventModel_Asset `json:"asset"`

	// Chain The chain on which the order was created
	Chain ChainIdentifier `json:"chain"`

	// Criteria For collection and trait offers, this object will contain the criteria needed to fulfill the offer.
	Criteria  OrderEventModel_Criteria      `json:"criteria"`
	EventType *OrderEventModelEventTypeEnum `json:"event_type,omitempty"`

	// ExpirationDate The Posix timestamp at which the order will close. When no expiration date is set, this value will be 0.
	ExpirationDate int `json:"expiration_date"`

	// Maker Maker of the order
	Maker string `json:"maker"`

	// OrderHash Order hash for the newly created order
	OrderHash string `json:"order_hash"`

	// OrderType An enumeration.
	OrderType OrderType         `json:"order_type"`
	Payment   EventPaymentModel `json:"payment"`

	// ProtocolAddress Exchange contract address for the order
	ProtocolAddress string `json:"protocol_address"`

	// Quantity Number of assets in the order
	Quantity int `json:"quantity"`

	// StartDate The Posix timestamp at which the order was created
	StartDate int `json:"start_date"`

	// Taker Taker of the order. This will only be set for private listings.
	Taker string `json:"taker"`
}

// OrderEventModelAsset1 defines model for .
type OrderEventModelAsset1 = map[string]interface{}

// OrderEventModel_Asset The asset being listed or bid on. Empty object for collection or trait offers.
type OrderEventModel_Asset struct {
	union json.RawMessage
}

// OrderEventModelCriteria1 defines model for .
type OrderEventModelCriteria1 = map[string]interface{}

// OrderEventModel_Criteria For collection and trait offers, this object will contain the criteria needed to fulfill the offer.
type OrderEventModel_Criteria struct {
	union json.RawMessage
}

// OrderEventModelEventTypeEnum defines model for OrderEventModelEventTypeEnum.
type OrderEventModelEventTypeEnum string

// OrderInput defines model for OrderInput.
type OrderInput struct {
	Parameters OrderInputComponents `json:"parameters"`

	// Signature Signature of the signed type data represented by the parameters field.
	Signature string `json:"signature"`
}

// OrderInputComponents defines model for OrderInputComponents.
type OrderInputComponents struct {
	// ConduitKey Indicates what conduit, if any, should be utilized as a source for token approvals when performing transfers. By default (i.e. when conduitKey is set to the zero hash), the offerer will grant transfer approvals to Seaport directly.
	// To utilize OpenSea's conduit, use 0x0000007b02230091a7ed01230072f7006a004d60a8d4e71d599b8104250f0000
	ConduitKey string `json:"conduitKey"`

	// Consideration Array of items which must be received by a recipient to fulfill the order. One of the consideration items must be the OpenSea marketplace fee.
	Consideration []ConsiderationItem `json:"consideration"`

	// Counter Must match the current counter for the given offerer. If you are unsure of the current counter, it can be [read from the contract](https://etherscan.io/address/0x00000000000000adc04c56bf30ac9d3c0aaf14dc#readContract#F2) on etherscan.
	Counter string `json:"counter"`

	// EndTime The block timestamp at which the order expires.
	EndTime int `json:"endTime"`

	// Offer Array of items that may be transferred from the offerer's account.
	Offer []OfferItem `json:"offer"`

	// Offerer The address which supplies all the items in the offer.
	Offerer string `json:"offerer"`

	// OrderType An enumeration.
	OrderType OrderType `json:"orderType"`

	// Salt an arbitrary source of entropy for the order
	Salt string `json:"salt"`

	// StartTime The block timestamp at which the order becomes active
	StartTime int `json:"startTime"`

	// TotalOriginalConsiderationItems Size of the consideration array.
	TotalOriginalConsiderationItems *int `json:"totalOriginalConsiderationItems,omitempty"`

	// Zone Optional secondary account attached the order which can cancel orders. Additionally, when the `OrderType` is Restricted, the zone or the offerer are the only entities which can execute the order.
	// For open orders, use the zero address.
	// For restricted orders, use the signed zone address <SIGNED_ZONE_ADDRESS>
	Zone string `json:"zone"`

	// ZoneHash A value that will be supplied to the zone when fulfilling restricted orders that the zone can utilize when making a determination on whether to authorize the order. Most often this value will be the zero hash 0x0000000000000000000000000000000000000000000000000000000000000000
	ZoneHash string `json:"zoneHash"`
}

// OrderInputWithProtocol defines model for OrderInputWithProtocol.
type OrderInputWithProtocol struct {
	Parameters OrderInputComponents `json:"parameters"`

	// ProtocolAddress Exchange contract address. Must be one of ['0x00000000000000adc04c56bf30ac9d3c0aaf14dc']
	ProtocolAddress string `json:"protocol_address"`

	// Signature Signature of the signed type data represented by the parameters field.
	Signature string `json:"signature"`
}

// OrderType An enumeration.
type OrderType = interface{}

// OrderTypeEnum * `basic` - basic
// * `dutch` - dutch
// * `english` - english
// * `criteria` - criteria
type OrderTypeEnum string

// OrderV2 Models OrderV2 objects to serialize to a 'similar' schema to what we have with OrderV1s
type OrderV2 struct {
	// Cancelled If true, the order maker has canceled the order which means it can no longer be filled.
	Cancelled bool `json:"cancelled"`

	// ClosingDate Date the order was closed
	ClosingDate time.Time `json:"closing_date"`

	// CreatedDate Date the order was created
	CreatedDate time.Time `json:"created_date"`

	// CriteriaProof A merkle root composed of the valid set of token identifiers for the order
	CriteriaProof *[]string `json:"criteria_proof"`

	// CurrentPrice Current price of the order
	CurrentPrice string `json:"current_price"`

	// ExpirationTime Timestamp representation of closing_date
	ExpirationTime *int `json:"expiration_time,omitempty"`

	// Finalized If true, the order has already been filled.
	Finalized bool `json:"finalized"`

	// ListingTime Timestamp representation of created_date
	ListingTime *int `json:"listing_time,omitempty"`

	// Maker The unique blockchain identifier, address, of the wallet which is the order maker.
	Maker *SimpleAccount `json:"maker,omitempty"`

	// MakerAssetBundle Deprecated Field.
	MakerAssetBundle *map[string]interface{} `json:"maker_asset_bundle,omitempty"`
	MakerFees        *[]SimpleFee            `json:"maker_fees,omitempty"`

	// MarkedInvalid If true, the order is currently invalid and can not be filled.
	MarkedInvalid *bool `json:"marked_invalid,omitempty"`

	// OrderHash An identifier for the order
	OrderHash string         `json:"order_hash"`
	OrderType *OrderTypeEnum `json:"order_type,omitempty"`

	// ProtocolAddress Exchange Contract Address. Typically the address of the Seaport contract.
	ProtocolAddress *string          `json:"protocol_address"`
	ProtocolData    *SerializedOrder `json:"protocol_data,omitempty"`

	// RelayId Deprecated Field
	RelayId *string `json:"relay_id,omitempty"`

	// RemainingQuantity The remaining quantity of the order that has not been filled. This is useful for erc1155 orders.
	RemainingQuantity int `json:"remaining_quantity"`

	// Side The side of the order, either bid (offer) or ask(listing).
	Side string `json:"side"`

	// Taker The unique blockchain identifier, address, of the wallet which is the order taker.
	Taker *SimpleAccount `json:"taker,omitempty"`

	// TakerAssetBundle Deprecated Field.
	TakerAssetBundle *map[string]interface{} `json:"taker_asset_bundle,omitempty"`
	TakerFees        *[]SimpleFee            `json:"taker_fees,omitempty"`
}

// OwnerModel defines model for OwnerModel.
type OwnerModel struct {
	// Address The unique public blockchain identifier for the owner wallet
	Address string `json:"address"`

	// Quantity The number of tokens owned
	Quantity int `json:"quantity"`
}

// PaginatedListingList defines model for PaginatedListingList.
type PaginatedListingList struct {
	// Listings OpenSea Listings
	Listings []Listing `json:"listings"`

	// Next Cursor for the next page of results
	Next string `json:"next"`
}

// PaginatedOfferList defines model for PaginatedOfferList.
type PaginatedOfferList struct {
	// Next Cursor for the next page of results
	Next   string  `json:"next"`
	Offers []Offer `json:"offers"`
}

// PartialParameters defines model for PartialParameters.
type PartialParameters struct {
	// Consideration One of the consideration items used when creating criteria offers.
	Consideration []SerializedConsiderationItem `json:"consideration"`

	// Zone Optional secondary account attached the order which can cancel orders. Additionally, when the `OrderType` is Restricted, the zone or the offerer are the only entities which can execute the order.
	// For open orders, use the zero address.
	// For restricted orders, use the signed zone address 0x000000e7ec00e7b300774b00001314b8610022b8
	Zone string `json:"zone"`

	// ZoneHash A value that will be supplied to the zone when fulfilling restricted orders that the zone can utilize when making a determination on whether to authorize the order. Most often this value will be the zero hash 0x0000000000000000000000000000000000000000000000000000000000000000
	ZoneHash string `json:"zoneHash"`
}

// PostCriteriaOfferInput defines model for PostCriteriaOfferInput.
type PostCriteriaOfferInput struct {
	// Criteria Criteria for the collection or trait offer
	Criteria Criteria `json:"criteria"`

	// ProtocolAddress Exchange contract address. Must be one of ['0x00000000000000adc04c56bf30ac9d3c0aaf14dc']
	ProtocolAddress string `json:"protocol_address"`

	// ProtocolData The signed order which will be submitted to Seaport
	ProtocolData OrderInput `json:"protocol_data"`
}

// PriceModel defines model for PriceModel.
type PriceModel struct {
	Currency string `json:"currency"`
	Decimals int    `json:"decimals"`
	Value    string `json:"value"`
}

// RankingFeatures defines model for RankingFeatures.
type RankingFeatures struct {
	// UniqueAttributeCount Deprecated Field.
	UniqueAttributeCount *int `json:"unique_attribute_count,omitempty"`
}

// RarityDataModel defines model for RarityDataModel.
type RarityDataModel struct {
	// CalculatedAt Deprecated Field
	CalculatedAt *string `json:"calculated_at,omitempty"`

	// MaxRank Deprecated Field
	MaxRank *int `json:"max_rank,omitempty"`

	// Rank Rarity Rank of the NFT in the collection
	Rank int `json:"rank"`

	// RankingFeatures Deprecated Field
	RankingFeatures *RankingFeatures `json:"ranking_features,omitempty"`

	// Score Deprecated Field
	Score *float32 `json:"score,omitempty"`

	// StrategyId Deprecated Field
	StrategyId *RarityStrategyId `json:"strategy_id,omitempty"`

	// StrategyVersion Deprecated Field
	StrategyVersion *string `json:"strategy_version,omitempty"`

	// TotalSupply Deprecated Field
	TotalSupply *int `json:"total_supply,omitempty"`
}

// RarityStrategyId Rarity algorithm used. Currently, always 'openrarity'
type RarityStrategyId = interface{}

// RedemptionEventModel defines model for RedemptionEventModel.
type RedemptionEventModel struct {
	// Asset The asset being redeemed.
	Asset RedemptionEventModel_Asset `json:"asset"`

	// Chain The chain on which the rededemption occurred
	Chain     ChainIdentifier                    `json:"chain"`
	EventType *RedemptionEventModelEventTypeEnum `json:"event_type,omitempty"`

	// FromAddress Address of the sender
	FromAddress string `json:"from_address"`

	// Quantity Number of assets redeemed
	Quantity int `json:"quantity"`

	// ToAddress Address of the recipient
	ToAddress string `json:"to_address"`

	// Transaction Transaction hash for the redemption
	Transaction string `json:"transaction"`
}

// RedemptionEventModelAsset1 defines model for .
type RedemptionEventModelAsset1 = map[string]interface{}

// RedemptionEventModel_Asset The asset being redeemed.
type RedemptionEventModel_Asset struct {
	union json.RawMessage
}

// RedemptionEventModelEventTypeEnum defines model for RedemptionEventModelEventTypeEnum.
type RedemptionEventModelEventTypeEnum string

// SafelistRequestStatus Status of the collection verification requests.
type SafelistRequestStatus = interface{}

// SaleEventModel defines model for SaleEventModel.
type SaleEventModel struct {
	// Chain The chain on which the order was fulfilled
	Chain ChainIdentifier `json:"chain"`

	// ClosingDate The Posix timestamp at which the transaction which filled the order occurred
	ClosingDate int                          `json:"closing_date"`
	EventType   *SaleEventModelEventTypeEnum `json:"event_type,omitempty"`

	// Maker Maker of the order
	Maker string `json:"maker"`

	// OrderHash Order hash for the order which was fulfilled
	OrderHash string            `json:"order_hash"`
	Payment   EventPaymentModel `json:"payment"`

	// ProtocolAddress Exchange contract address which fulfilled the order
	ProtocolAddress string `json:"protocol_address"`

	// Quantity Number of assets transferred
	Quantity int `json:"quantity"`

	// Taker Taker of the order
	Taker string `json:"taker"`

	// Transaction Transaction hash for the order fulfillment
	Transaction string `json:"transaction"`
}

// SaleEventModelEventTypeEnum defines model for SaleEventModelEventTypeEnum.
type SaleEventModelEventTypeEnum string

// SerializedConsiderationItem defines model for SerializedConsiderationItem.
type SerializedConsiderationItem struct {
	// EndAmount When endAmount differs from `startAmount`, the realized amount is calculated linearly based on the time elapsed since the order became active.
	EndAmount string `json:"endAmount"`

	// IdentifierOrCriteria The ERC721 or ERC1155 token identifier or, in the case of a criteria-based item type, a merkle root composed of the valid set of token identifiers for the item. This value will be ignored for Ether and ERC20 item types, and can optionally be zero for criteria-based item types to allow for any identifier.
	IdentifierOrCriteria string `json:"identifierOrCriteria"`

	// ItemType 0 - Native - Ether (or other native token for the given chain)
	// 1 - ERC20
	// 2 - ERC721
	// 3 - ERC1155
	// 4 - ERC721 with criteria
	// 5 - ERC1155 with criteria
	ItemType ItemType `json:"itemType"`

	// Recipient The address which will receive the consideration item when the order is executed.
	Recipient string `json:"recipient"`

	// StartAmount The amount of the token in question that will be required should the order be fulfilled.
	StartAmount string `json:"startAmount"`

	// Token The item's token contract (with the null address used for native tokens)
	Token string `json:"token"`
}

// SerializedOfferItem defines model for SerializedOfferItem.
type SerializedOfferItem struct {
	// EndAmount When endAmount differs from `startAmount`, the realized amount is calculated linearly based on the time elapsed since the order became active.
	EndAmount string `json:"endAmount"`

	// IdentifierOrCriteria The ERC721 or ERC1155 token identifier or, in the case of a criteria-based item type, a merkle root composed of the valid set of token identifiers for the item. This value will be ignored for Ether and ERC20 item types, and can optionally be zero for criteria-based item types to allow for any identifier.
	IdentifierOrCriteria string `json:"identifierOrCriteria"`

	// ItemType 0 - Native - Ether (or other native token for the given chain)
	// 1 - ERC20
	// 2 - ERC721
	// 3 - ERC1155
	// 4 - ERC721 with criteria
	// 5 - ERC1155 with criteria
	ItemType ItemType `json:"itemType"`

	// StartAmount The amount of the token in question that will be required should the order be fulfilled.
	StartAmount string `json:"startAmount"`

	// Token The item's token contract (with the null address used for native tokens)
	Token string `json:"token"`
}

// SerializedOrder defines model for SerializedOrder.
type SerializedOrder struct {
	Parameters SerializedOrderComponents `json:"parameters"`

	// Signature The order maker's signature used to validate the order.
	Signature *string `json:"signature,omitempty"`
}

// SerializedOrderComponents defines model for SerializedOrderComponents.
type SerializedOrderComponents struct {
	// ConduitKey Indicates what conduit, if any, should be utilized as a source for token approvals when performing transfers. By default (i.e. when conduitKey is set to the zero hash), the offerer will grant transfer approvals to Seaport directly.
	// To utilize OpenSea's conduit, use 0x0000007b02230091a7ed01230072f7006a004d60a8d4e71d599b8104250f0000
	ConduitKey    string                            `json:"conduitKey"`
	Consideration []SerializedConsiderationItem     `json:"consideration"`
	Counter       SerializedOrderComponents_Counter `json:"counter"`

	// EndTime The block timestamp at which the order expires
	EndTime string                `json:"endTime"`
	Offer   []SerializedOfferItem `json:"offer"`

	// Offerer The address which supplies all the items in the offer.
	Offerer string `json:"offerer"`

	// OrderType The type of order, which determines how it can be executed.
	// 0 = Full Open - No partial fills, anyone can execute
	// 1 = Partial Open - Partial fills supported, anyone can execute
	// 2 = Full Restricted - No partial fills, only offerer or zone can check if it can be executed
	// 3 = Partial Restricted - Partial fills supported, only offerer or zone can check if it can be executed
	// 4 = Contract - Contract order type, for contract offerers that can dynamically generate orders. Introduced in Seaport v1.4 and currently unsupported
	OrderType CoreBlockchainEvmAbiModelsSeaportOrderType `json:"orderType"`

	// Salt an arbitrary source of entropy for the order
	Salt string `json:"salt"`

	// StartTime The block timestamp at which the order becomes active
	StartTime string `json:"startTime"`

	// TotalOriginalConsiderationItems Size of the consideration array.
	TotalOriginalConsiderationItems *int `json:"totalOriginalConsiderationItems,omitempty"`

	// Zone Optional secondary account attached the order which can cancel orders. Additionally, when the `OrderType` is Restricted, the zone or the offerer are the only entities which can execute the order.
	// For open orders, use the zero address.
	// For restricted orders, use the signed zone address <SIGNED_ZONE_ADDRESS>
	Zone string `json:"zone"`

	// ZoneHash A value that will be supplied to the zone when fulfilling restricted orders that the zone can utilize when making a determination on whether to authorize the order. Most often this value will be the zero hash 0x0000000000000000000000000000000000000000000000000000000000000000
	ZoneHash string `json:"zoneHash"`
}

// SerializedOrderComponentsCounter0 defines model for .
type SerializedOrderComponentsCounter0 = int

// SerializedOrderComponentsCounter1 defines model for .
type SerializedOrderComponentsCounter1 = string

// SerializedOrderComponents_Counter defines model for SerializedOrderComponents.Counter.
type SerializedOrderComponents_Counter struct {
	union json.RawMessage
}

// SignedSimpleOrderV2 OpenSea Order Object
type SignedSimpleOrderV2 struct {
	// Cancelled If true, the order maker has canceled the order which means it can no longer be filled.
	Cancelled bool `json:"cancelled"`

	// ClosingDate Date the order was closed
	ClosingDate time.Time `json:"closing_date"`

	// CreatedDate Date the order was created
	CreatedDate time.Time `json:"created_date"`

	// CriteriaProof A merkle root composed of the valid set of token identifiers for the order
	CriteriaProof *[]string `json:"criteria_proof"`

	// CurrentPrice Current price of the order
	CurrentPrice string `json:"current_price"`

	// ExpirationTime Timestamp representation of closing_date
	ExpirationTime *int `json:"expiration_time,omitempty"`

	// Finalized If true, the order has already been filled.
	Finalized bool `json:"finalized"`

	// ListingTime Timestamp representation of created_date
	ListingTime *int `json:"listing_time,omitempty"`

	// Maker The unique blockchain identifier, address, of the wallet which is the order maker.
	Maker     *SimpleAccount `json:"maker,omitempty"`
	MakerFees *[]SimpleFee   `json:"maker_fees,omitempty"`

	// MarkedInvalid If true, the order is currently invalid and can not be filled.
	MarkedInvalid *bool `json:"marked_invalid,omitempty"`

	// OrderHash An identifier for the order
	OrderHash string         `json:"order_hash"`
	OrderType *OrderTypeEnum `json:"order_type,omitempty"`

	// ProtocolAddress Exchange Contract Address. Typically the address of the Seaport contract.
	ProtocolAddress *string          `json:"protocol_address"`
	ProtocolData    *SerializedOrder `json:"protocol_data,omitempty"`

	// RelayId Deprecated Field
	RelayId *string `json:"relay_id,omitempty"`

	// RemainingQuantity The remaining quantity of the order that has not been filled. This is useful for erc1155 orders.
	RemainingQuantity int `json:"remaining_quantity"`

	// Side The side of the order, either bid (offer) or ask(listing).
	Side string `json:"side"`

	// Taker The unique blockchain identifier, address, of the wallet which is the order taker.
	Taker     *SimpleAccount `json:"taker,omitempty"`
	TakerFees *[]SimpleFee   `json:"taker_fees,omitempty"`
}

// SimpleAccount defines model for SimpleAccount.
type SimpleAccount struct {
	// Address The unique blockchain identifier, address, of the account.
	Address *string     `json:"address,omitempty"`
	Config  *ConfigEnum `json:"config,omitempty"`

	// ProfileImgUrl A placeholder image. For the actual profile image, call the Get Account endpoint.
	ProfileImgUrl *string `json:"profile_img_url,omitempty"`
	User          *int    `json:"user"`
}

// SimpleFee defines model for SimpleFee.
type SimpleFee struct {
	Account     *SimpleAccount `json:"account,omitempty"`
	BasisPoints string         `json:"basis_points"`
}

// SocialMediaAccountModel defines model for SocialMediaAccountModel.
type SocialMediaAccountModel struct {
	// Platform The social media platform, e.g. twitter or instagram
	Platform string `json:"platform"`

	// Username The username for the social media platform
	Username string `json:"username"`
}

// Trait defines model for Trait.
type Trait struct {
	Type  string `json:"type"`
	Value string `json:"value"`
}

// TraitModel defines model for TraitModel.
type TraitModel struct {
	// DisplayType A field indicating how to display. None is used for string traits.
	DisplayType *DisplayTypeField `json:"display_type,omitempty"`

	// MaxValue Ceiling for possible numeric trait values
	MaxValue string `json:"max_value"`

	// Order Deprecated Field
	Order *int `json:"order,omitempty"`

	// TraitCount Deprecated Field. Use Get Collection API instead.
	TraitCount *int `json:"trait_count,omitempty"`

	// TraitType The name of the trait category (e.g. 'Background')
	TraitType string `json:"trait_type"`

	// Value The value of the trait (e.g. 'Red')
	Value TraitModel_Value `json:"value"`
}

// TraitModelValue0 defines model for .
type TraitModelValue0 = float32

// TraitModelValue1 defines model for .
type TraitModelValue1 = int

// TraitModelValue2 defines model for .
type TraitModelValue2 = openapi_types.Date

// TraitModelValue3 defines model for .
type TraitModelValue3 = string

// TraitModel_Value The value of the trait (e.g. 'Red')
type TraitModel_Value struct {
	union json.RawMessage
}

// Transaction defines model for Transaction.
type Transaction struct {
	// Chain Numeric Chain Identifier.
	Chain int `json:"chain"`

	// Function Seaport protocol contract method to use to fulfill the order.
	Function string `json:"function"`

	// InputData Decoded Call Data.
	InputData map[string]interface{} `json:"input_data"`

	// To Protocol contract address to use fto fulfill the order.
	To string `json:"to"`

	// Value Wei value of the transaction.
	Value int `json:"value"`
}

// TransferEventModel defines model for TransferEventModel.
type TransferEventModel struct {
	// Chain The chain on which the transfer occurred
	Chain     ChainIdentifier                  `json:"chain"`
	EventType *TransferEventModelEventTypeEnum `json:"event_type,omitempty"`

	// FromAddress Address of the sender
	FromAddress string `json:"from_address"`

	// Quantity Number of assets transferred
	Quantity int `json:"quantity"`

	// ToAddress Address of the recipient
	ToAddress string `json:"to_address"`

	// Transaction Transaction hash for the transfer
	Transaction string `json:"transaction"`
}

// TransferEventModelEventTypeEnum defines model for TransferEventModelEventTypeEnum.
type TransferEventModelEventTypeEnum string

// CoreBlockchainEvmAbiModelsSeaportOrderType The type of order, which determines how it can be executed.
// 0 = Full Open - No partial fills, anyone can execute
// 1 = Partial Open - Partial fills supported, anyone can execute
// 2 = Full Restricted - No partial fills, only offerer or zone can check if it can be executed
// 3 = Partial Restricted - Partial fills supported, only offerer or zone can check if it can be executed
// 4 = Contract - Contract order type, for contract offerers that can dynamically generate orders. Introduced in Seaport v1.4 and currently unsupported
type CoreBlockchainEvmAbiModelsSeaportOrderType int

// CoreTypesOrderType basic - Quantities are fixed. Used for fixed price listings and offers.
// dutch - The quantity represents the starting price.
// english - The quantity represents the minimum price.
// criteria - The items that are accepted by this offer will be found in the criteria fields.
type CoreTypesOrderType = interface{}

// ListNftsByAccountParams defines parameters for ListNftsByAccount.
type ListNftsByAccountParams struct {
	// Collection Unique string to identify a collection on OpenSea. This can be found by visiting the collection on the OpenSea website and noting the last path parameter.
	Collection *string `form:"collection,omitempty" json:"collection,omitempty"`

	// Limit The number of NFTs to return. Must be between 1 and 50. Default: 50
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Next The cursor for the next page of results. This is returned from a previous request.
	Next *string `form:"next,omitempty" json:"next,omitempty"`
}

// ListNftsByAccountParamsChain defines parameters for ListNftsByAccount.
type ListNftsByAccountParamsChain string

// GetContractParamsChain defines parameters for GetContract.
type GetContractParamsChain string

// ListNftsByContractParams defines parameters for ListNftsByContract.
type ListNftsByContractParams struct {
	// Limit The number of NFTs to return. Must be between 1 and 50. Default: 50
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Next The cursor for the next page of results. This is returned from a previous request.
	Next *string `form:"next,omitempty" json:"next,omitempty"`
}

// ListNftsByContractParamsChain defines parameters for ListNftsByContract.
type ListNftsByContractParamsChain string

// GetNftParamsChain defines parameters for GetNft.
type GetNftParamsChain string

// RefreshNftParamsChain defines parameters for RefreshNft.
type RefreshNftParamsChain string

// ListNftsByCollectionParams defines parameters for ListNftsByCollection.
type ListNftsByCollectionParams struct {
	// Limit The number of NFTs to return. Must be between 1 and 50. Default: 50
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Next The cursor for the next page of results. This is returned from a previous request.
	Next *string `form:"next,omitempty" json:"next,omitempty"`
}

// ListCollectionsParams defines parameters for ListCollections.
type ListCollectionsParams struct {
	// ChainIdentifier The blockchain on which to filter the results
	ChainIdentifier *string `form:"chain_identifier,omitempty" json:"chain_identifier,omitempty"`

	// IncludeHidden If true, will return hidden collections. Default: false
	IncludeHidden *bool `form:"include_hidden,omitempty" json:"include_hidden,omitempty"`

	// Limit The number of collections to return. Must be between 1 and 100. Default: 100
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Next The cursor for the next page of results. This is returned from a previous request.
	Next *string `form:"next,omitempty" json:"next,omitempty"`
}

// ListEventsByAccountParams defines parameters for ListEventsByAccount.
type ListEventsByAccountParams struct {
	// After Filter to only include events that occurred at or after the given timestamp. The Unix epoch timstamp must be in seconds
	After *float32 `form:"after,omitempty" json:"after,omitempty"`

	// Before Filter to only include events that occurred before the given timestamp. The Unix epoch timstamp must be in seconds.
	Before *float32 `form:"before,omitempty" json:"before,omitempty"`

	// Chain The blockchain on which to filter the results.
	Chain *ListEventsByAccountParamsChain `form:"chain,omitempty" json:"chain,omitempty"`

	// EventType The type of event to filter by. If not provided, only sales will be returned.
	EventType *[]ListEventsByAccountParamsEventType `form:"event_type,omitempty" json:"event_type,omitempty"`

	// Next The cursor for the next page of results. This is returned from a previous request.
	Next *string `form:"next,omitempty" json:"next,omitempty"`
}

// ListEventsByAccountParamsChain defines parameters for ListEventsByAccount.
type ListEventsByAccountParamsChain string

// ListEventsByAccountParamsEventType defines parameters for ListEventsByAccount.
type ListEventsByAccountParamsEventType string

// ListEventsByNftParams defines parameters for ListEventsByNft.
type ListEventsByNftParams struct {
	// After Filter to only include events that occurred at or after the given timestamp. The Unix epoch timstamp must be in seconds
	After *float32 `form:"after,omitempty" json:"after,omitempty"`

	// Before Filter to only include events that occurred before the given timestamp. The Unix epoch timstamp must be in seconds.
	Before *float32 `form:"before,omitempty" json:"before,omitempty"`

	// EventType The type of event to filter by. If not provided, only sales will be returned.
	EventType *[]ListEventsByNftParamsEventType `form:"event_type,omitempty" json:"event_type,omitempty"`

	// Next The cursor for the next page of results. This is returned from a previous request.
	Next *string `form:"next,omitempty" json:"next,omitempty"`
}

// ListEventsByNftParamsEventType defines parameters for ListEventsByNft.
type ListEventsByNftParamsEventType string

// ListEventsByNftParamsChain defines parameters for ListEventsByNft.
type ListEventsByNftParamsChain string

// ListEventsByCollectionParams defines parameters for ListEventsByCollection.
type ListEventsByCollectionParams struct {
	// After Filter to only include events that occurred at or after the given timestamp. The Unix epoch timstamp must be in seconds
	After *float32 `form:"after,omitempty" json:"after,omitempty"`

	// Before Filter to only include events that occurred before the given timestamp. The Unix epoch timstamp must be in seconds.
	Before *float32 `form:"before,omitempty" json:"before,omitempty"`

	// EventType The type of event to filter by. If not provided, only sales will be returned.
	EventType *[]ListEventsByCollectionParamsEventType `form:"event_type,omitempty" json:"event_type,omitempty"`

	// Next The cursor for the next page of results. This is returned from a previous request.
	Next *string `form:"next,omitempty" json:"next,omitempty"`
}

// ListEventsByCollectionParamsEventType defines parameters for ListEventsByCollection.
type ListEventsByCollectionParamsEventType string

// GetAllListingsOnCollectionV2Params defines parameters for GetAllListingsOnCollectionV2.
type GetAllListingsOnCollectionV2Params struct {
	// Limit The number of listings to return. Must be between 1 and 100. Default: 100
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Next The cursor for the next page of results. This is returned from a previous request.
	Next *string `form:"next,omitempty" json:"next,omitempty"`
}

// GetAllOffersOnCollectionV2Params defines parameters for GetAllOffersOnCollectionV2.
type GetAllOffersOnCollectionV2Params struct {
	// Limit The number of offers to return. Must be between 1 and 100. Default: 100
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Next The cursor for the next page of results. This is returned from a previous request.
	Next *string `form:"next,omitempty" json:"next,omitempty"`
}

// GetTraitOffersV2Params defines parameters for GetTraitOffersV2.
type GetTraitOffersV2Params struct {
	// FloatValue The value of the trait (e.g. `0.5`). This is only used for decimal-based numeric traits to ensure it is parsed correctly.
	FloatValue *float32 `form:"float_value,omitempty" json:"float_value,omitempty"`

	// IntValue The value of the trait (e.g. `10`). This is only used for numeric traits to ensure it is parsed correctly.
	IntValue *int `form:"int_value,omitempty" json:"int_value,omitempty"`

	// Type The name of the trait (e.g. 'Background')
	Type *string `form:"type,omitempty" json:"type,omitempty"`

	// Value The value of the trait (e.g. 'Red')
	Value *string `form:"value,omitempty" json:"value,omitempty"`
}

// GetOrderParamsChain defines parameters for GetOrder.
type GetOrderParamsChain string

// GetOrderParamsProtocolAddress defines parameters for GetOrder.
type GetOrderParamsProtocolAddress string

// GetListingsParams defines parameters for GetListings.
type GetListingsParams struct {
	// AssetContractAddress Filter results by the contract address for NFT(s).
	//  NOTE: If used, token_ids or token_id is required.
	AssetContractAddress *string `form:"asset_contract_address,omitempty" json:"asset_contract_address,omitempty"`

	// Bundled Restricts results to only include orders that are bundles of NFTs. Default: false
	Bundled *bool `form:"bundled,omitempty" json:"bundled,omitempty"`

	// Cursor The cursor for the next page of results. This is returned from a previous request.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit The number of orders to return. Must be between 1 and 50. Default: 20
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// ListedAfter Filter to only include orders that were listed after the given timestamp. This is a Unix epoch timestamp in seconds.
	ListedAfter *time.Time `form:"listed_after,omitempty" json:"listed_after,omitempty"`

	// ListedBefore Filter to only include orders that were listed before the given timestamp. This is a Unix epoch timestamp in seconds.
	ListedBefore *time.Time `form:"listed_before,omitempty" json:"listed_before,omitempty"`

	// Maker Filter results by the order maker's wallet address.
	Maker *string `form:"maker,omitempty" json:"maker,omitempty"`

	// OrderBy The order in which to sort the results. Default: created_date
	//  NOTE: If `eth_price` is used, `asset_contract_address` and `token_id` are required.
	OrderBy *GetListingsParamsOrderBy `form:"order_by,omitempty" json:"order_by,omitempty"`

	// OrderDirection The direction in which to sort the results. Default: desc
	OrderDirection *GetListingsParamsOrderDirection `form:"order_direction,omitempty" json:"order_direction,omitempty"`

	// PaymentTokenAddress Payment Token Address to filter results. This ensures all returned orders are listed in a single currency.
	PaymentTokenAddress *string `form:"payment_token_address,omitempty" json:"payment_token_address,omitempty"`

	// Taker Filter results by the order taker's wallet address.
	Taker *string `form:"taker,omitempty" json:"taker,omitempty"`

	// TokenIds An array of token IDs to search for (e.g. ?token_ids=1&token_ids=209). This endpoint will return a list of orders with token_id matching any of the IDs in this array.
	//  NOTE: If used, asset_contract_address is required.
	TokenIds *int `form:"token_ids,omitempty" json:"token_ids,omitempty"`
}

// GetListingsParamsOrderBy defines parameters for GetListings.
type GetListingsParamsOrderBy string

// GetListingsParamsOrderDirection defines parameters for GetListings.
type GetListingsParamsOrderDirection string

// GetListingsParamsChain defines parameters for GetListings.
type GetListingsParamsChain string

// GetListingsParamsProtocol defines parameters for GetListings.
type GetListingsParamsProtocol string

// PostListingParamsChain defines parameters for PostListing.
type PostListingParamsChain string

// PostListingParamsProtocol defines parameters for PostListing.
type PostListingParamsProtocol string

// GetOffersParams defines parameters for GetOffers.
type GetOffersParams struct {
	// AssetContractAddress Filter results by the contract address for NFT(s).
	//  NOTE: If used, token_ids or token_id is required.
	AssetContractAddress *string `form:"asset_contract_address,omitempty" json:"asset_contract_address,omitempty"`

	// Bundled Restricts results to only include orders that are bundles of NFTs. Default: false
	Bundled *bool `form:"bundled,omitempty" json:"bundled,omitempty"`

	// Cursor The cursor for the next page of results. This is returned from a previous request.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit The number of orders to return. Must be between 1 and 50. Default: 20
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// ListedAfter Filter to only include orders that were listed after the given timestamp. This is a Unix epoch timestamp in seconds.
	ListedAfter *time.Time `form:"listed_after,omitempty" json:"listed_after,omitempty"`

	// ListedBefore Filter to only include orders that were listed before the given timestamp. This is a Unix epoch timestamp in seconds.
	ListedBefore *time.Time `form:"listed_before,omitempty" json:"listed_before,omitempty"`

	// Maker Filter results by the order maker's wallet address.
	Maker *string `form:"maker,omitempty" json:"maker,omitempty"`

	// OrderBy The order in which to sort the results. Default: created_date
	//  NOTE: If `eth_price` is used, `asset_contract_address` and `token_id` are required.
	OrderBy *GetOffersParamsOrderBy `form:"order_by,omitempty" json:"order_by,omitempty"`

	// OrderDirection The direction in which to sort the results. Default: desc
	OrderDirection *GetOffersParamsOrderDirection `form:"order_direction,omitempty" json:"order_direction,omitempty"`

	// PaymentTokenAddress Payment Token Address to filter results. This ensures all returned orders are listed in a single currency.
	PaymentTokenAddress *string `form:"payment_token_address,omitempty" json:"payment_token_address,omitempty"`

	// Taker Filter results by the order taker's wallet address.
	Taker *string `form:"taker,omitempty" json:"taker,omitempty"`

	// TokenIds An array of token IDs to search for (e.g. ?token_ids=1&token_ids=209). This endpoint will return a list of orders with token_id matching any of the IDs in this array.
	//  NOTE: If used, asset_contract_address is required.
	TokenIds *int `form:"token_ids,omitempty" json:"token_ids,omitempty"`
}

// GetOffersParamsOrderBy defines parameters for GetOffers.
type GetOffersParamsOrderBy string

// GetOffersParamsOrderDirection defines parameters for GetOffers.
type GetOffersParamsOrderDirection string

// GetOffersParamsChain defines parameters for GetOffers.
type GetOffersParamsChain string

// GetOffersParamsProtocol defines parameters for GetOffers.
type GetOffersParamsProtocol string

// PostOfferParamsChain defines parameters for PostOffer.
type PostOfferParamsChain string

// PostOfferParamsProtocol defines parameters for PostOffer.
type PostOfferParamsProtocol string

// GenerateListingFulfillmentDataV2JSONRequestBody defines body for GenerateListingFulfillmentDataV2 for application/json ContentType.
type GenerateListingFulfillmentDataV2JSONRequestBody = GenerateListingFulfillmentInput

// GenerateListingFulfillmentDataV2FormdataRequestBody defines body for GenerateListingFulfillmentDataV2 for application/x-www-form-urlencoded ContentType.
type GenerateListingFulfillmentDataV2FormdataRequestBody = GenerateListingFulfillmentInput

// GenerateListingFulfillmentDataV2MultipartRequestBody defines body for GenerateListingFulfillmentDataV2 for multipart/form-data ContentType.
type GenerateListingFulfillmentDataV2MultipartRequestBody = GenerateListingFulfillmentInput

// PostCriteriaOfferV2JSONRequestBody defines body for PostCriteriaOfferV2 for application/json ContentType.
type PostCriteriaOfferV2JSONRequestBody = PostCriteriaOfferInput

// PostCriteriaOfferV2FormdataRequestBody defines body for PostCriteriaOfferV2 for application/x-www-form-urlencoded ContentType.
type PostCriteriaOfferV2FormdataRequestBody = PostCriteriaOfferInput

// PostCriteriaOfferV2MultipartRequestBody defines body for PostCriteriaOfferV2 for multipart/form-data ContentType.
type PostCriteriaOfferV2MultipartRequestBody = PostCriteriaOfferInput

// BuildOfferV2JSONRequestBody defines body for BuildOfferV2 for application/json ContentType.
type BuildOfferV2JSONRequestBody = BuildOfferInput

// BuildOfferV2FormdataRequestBody defines body for BuildOfferV2 for application/x-www-form-urlencoded ContentType.
type BuildOfferV2FormdataRequestBody = BuildOfferInput

// BuildOfferV2MultipartRequestBody defines body for BuildOfferV2 for multipart/form-data ContentType.
type BuildOfferV2MultipartRequestBody = BuildOfferInput

// GenerateOfferFulfillmentDataV2JSONRequestBody defines body for GenerateOfferFulfillmentDataV2 for application/json ContentType.
type GenerateOfferFulfillmentDataV2JSONRequestBody = GenerateOfferFulfillmentInput

// GenerateOfferFulfillmentDataV2FormdataRequestBody defines body for GenerateOfferFulfillmentDataV2 for application/x-www-form-urlencoded ContentType.
type GenerateOfferFulfillmentDataV2FormdataRequestBody = GenerateOfferFulfillmentInput

// GenerateOfferFulfillmentDataV2MultipartRequestBody defines body for GenerateOfferFulfillmentDataV2 for multipart/form-data ContentType.
type GenerateOfferFulfillmentDataV2MultipartRequestBody = GenerateOfferFulfillmentInput

// PostListingJSONRequestBody defines body for PostListing for application/json ContentType.
type PostListingJSONRequestBody = OrderInputWithProtocol

// PostListingFormdataRequestBody defines body for PostListing for application/x-www-form-urlencoded ContentType.
type PostListingFormdataRequestBody = OrderInputWithProtocol

// PostListingMultipartRequestBody defines body for PostListing for multipart/form-data ContentType.
type PostListingMultipartRequestBody = OrderInputWithProtocol

// PostOfferJSONRequestBody defines body for PostOffer for application/json ContentType.
type PostOfferJSONRequestBody = OrderInputWithProtocol

// PostOfferFormdataRequestBody defines body for PostOffer for application/x-www-form-urlencoded ContentType.
type PostOfferFormdataRequestBody = OrderInputWithProtocol

// PostOfferMultipartRequestBody defines body for PostOffer for multipart/form-data ContentType.
type PostOfferMultipartRequestBody = OrderInputWithProtocol

// AsListing returns the union data inside the GetOrderResult_Order as a Listing
func (t GetOrderResult_Order) AsListing() (Listing, error) {
	var body Listing
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromListing overwrites any union data inside the GetOrderResult_Order as the provided Listing
func (t *GetOrderResult_Order) FromListing(v Listing) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeListing performs a merge with any union data inside the GetOrderResult_Order, using the provided Listing
func (t *GetOrderResult_Order) MergeListing(v Listing) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsOffer returns the union data inside the GetOrderResult_Order as a Offer
func (t GetOrderResult_Order) AsOffer() (Offer, error) {
	var body Offer
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOffer overwrites any union data inside the GetOrderResult_Order as the provided Offer
func (t *GetOrderResult_Order) FromOffer(v Offer) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOffer performs a merge with any union data inside the GetOrderResult_Order, using the provided Offer
func (t *GetOrderResult_Order) MergeOffer(v Offer) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t GetOrderResult_Order) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *GetOrderResult_Order) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsCancelEventModel returns the union data inside the ListEventsResponse_AssetEvents_Item as a CancelEventModel
func (t ListEventsResponse_AssetEvents_Item) AsCancelEventModel() (CancelEventModel, error) {
	var body CancelEventModel
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCancelEventModel overwrites any union data inside the ListEventsResponse_AssetEvents_Item as the provided CancelEventModel
func (t *ListEventsResponse_AssetEvents_Item) FromCancelEventModel(v CancelEventModel) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCancelEventModel performs a merge with any union data inside the ListEventsResponse_AssetEvents_Item, using the provided CancelEventModel
func (t *ListEventsResponse_AssetEvents_Item) MergeCancelEventModel(v CancelEventModel) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsOrderEventModel returns the union data inside the ListEventsResponse_AssetEvents_Item as a OrderEventModel
func (t ListEventsResponse_AssetEvents_Item) AsOrderEventModel() (OrderEventModel, error) {
	var body OrderEventModel
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOrderEventModel overwrites any union data inside the ListEventsResponse_AssetEvents_Item as the provided OrderEventModel
func (t *ListEventsResponse_AssetEvents_Item) FromOrderEventModel(v OrderEventModel) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOrderEventModel performs a merge with any union data inside the ListEventsResponse_AssetEvents_Item, using the provided OrderEventModel
func (t *ListEventsResponse_AssetEvents_Item) MergeOrderEventModel(v OrderEventModel) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSaleEventModel returns the union data inside the ListEventsResponse_AssetEvents_Item as a SaleEventModel
func (t ListEventsResponse_AssetEvents_Item) AsSaleEventModel() (SaleEventModel, error) {
	var body SaleEventModel
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSaleEventModel overwrites any union data inside the ListEventsResponse_AssetEvents_Item as the provided SaleEventModel
func (t *ListEventsResponse_AssetEvents_Item) FromSaleEventModel(v SaleEventModel) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSaleEventModel performs a merge with any union data inside the ListEventsResponse_AssetEvents_Item, using the provided SaleEventModel
func (t *ListEventsResponse_AssetEvents_Item) MergeSaleEventModel(v SaleEventModel) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsTransferEventModel returns the union data inside the ListEventsResponse_AssetEvents_Item as a TransferEventModel
func (t ListEventsResponse_AssetEvents_Item) AsTransferEventModel() (TransferEventModel, error) {
	var body TransferEventModel
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTransferEventModel overwrites any union data inside the ListEventsResponse_AssetEvents_Item as the provided TransferEventModel
func (t *ListEventsResponse_AssetEvents_Item) FromTransferEventModel(v TransferEventModel) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTransferEventModel performs a merge with any union data inside the ListEventsResponse_AssetEvents_Item, using the provided TransferEventModel
func (t *ListEventsResponse_AssetEvents_Item) MergeTransferEventModel(v TransferEventModel) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsRedemptionEventModel returns the union data inside the ListEventsResponse_AssetEvents_Item as a RedemptionEventModel
func (t ListEventsResponse_AssetEvents_Item) AsRedemptionEventModel() (RedemptionEventModel, error) {
	var body RedemptionEventModel
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRedemptionEventModel overwrites any union data inside the ListEventsResponse_AssetEvents_Item as the provided RedemptionEventModel
func (t *ListEventsResponse_AssetEvents_Item) FromRedemptionEventModel(v RedemptionEventModel) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRedemptionEventModel performs a merge with any union data inside the ListEventsResponse_AssetEvents_Item, using the provided RedemptionEventModel
func (t *ListEventsResponse_AssetEvents_Item) MergeRedemptionEventModel(v RedemptionEventModel) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ListEventsResponse_AssetEvents_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ListEventsResponse_AssetEvents_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsNftModel returns the union data inside the OrderEventModel_Asset as a NftModel
func (t OrderEventModel_Asset) AsNftModel() (NftModel, error) {
	var body NftModel
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNftModel overwrites any union data inside the OrderEventModel_Asset as the provided NftModel
func (t *OrderEventModel_Asset) FromNftModel(v NftModel) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNftModel performs a merge with any union data inside the OrderEventModel_Asset, using the provided NftModel
func (t *OrderEventModel_Asset) MergeNftModel(v NftModel) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsOrderEventModelAsset1 returns the union data inside the OrderEventModel_Asset as a OrderEventModelAsset1
func (t OrderEventModel_Asset) AsOrderEventModelAsset1() (OrderEventModelAsset1, error) {
	var body OrderEventModelAsset1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOrderEventModelAsset1 overwrites any union data inside the OrderEventModel_Asset as the provided OrderEventModelAsset1
func (t *OrderEventModel_Asset) FromOrderEventModelAsset1(v OrderEventModelAsset1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOrderEventModelAsset1 performs a merge with any union data inside the OrderEventModel_Asset, using the provided OrderEventModelAsset1
func (t *OrderEventModel_Asset) MergeOrderEventModelAsset1(v OrderEventModelAsset1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t OrderEventModel_Asset) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *OrderEventModel_Asset) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsCriteria returns the union data inside the OrderEventModel_Criteria as a Criteria
func (t OrderEventModel_Criteria) AsCriteria() (Criteria, error) {
	var body Criteria
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCriteria overwrites any union data inside the OrderEventModel_Criteria as the provided Criteria
func (t *OrderEventModel_Criteria) FromCriteria(v Criteria) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCriteria performs a merge with any union data inside the OrderEventModel_Criteria, using the provided Criteria
func (t *OrderEventModel_Criteria) MergeCriteria(v Criteria) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsOrderEventModelCriteria1 returns the union data inside the OrderEventModel_Criteria as a OrderEventModelCriteria1
func (t OrderEventModel_Criteria) AsOrderEventModelCriteria1() (OrderEventModelCriteria1, error) {
	var body OrderEventModelCriteria1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOrderEventModelCriteria1 overwrites any union data inside the OrderEventModel_Criteria as the provided OrderEventModelCriteria1
func (t *OrderEventModel_Criteria) FromOrderEventModelCriteria1(v OrderEventModelCriteria1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOrderEventModelCriteria1 performs a merge with any union data inside the OrderEventModel_Criteria, using the provided OrderEventModelCriteria1
func (t *OrderEventModel_Criteria) MergeOrderEventModelCriteria1(v OrderEventModelCriteria1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t OrderEventModel_Criteria) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *OrderEventModel_Criteria) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsNftModel returns the union data inside the RedemptionEventModel_Asset as a NftModel
func (t RedemptionEventModel_Asset) AsNftModel() (NftModel, error) {
	var body NftModel
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNftModel overwrites any union data inside the RedemptionEventModel_Asset as the provided NftModel
func (t *RedemptionEventModel_Asset) FromNftModel(v NftModel) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNftModel performs a merge with any union data inside the RedemptionEventModel_Asset, using the provided NftModel
func (t *RedemptionEventModel_Asset) MergeNftModel(v NftModel) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsRedemptionEventModelAsset1 returns the union data inside the RedemptionEventModel_Asset as a RedemptionEventModelAsset1
func (t RedemptionEventModel_Asset) AsRedemptionEventModelAsset1() (RedemptionEventModelAsset1, error) {
	var body RedemptionEventModelAsset1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRedemptionEventModelAsset1 overwrites any union data inside the RedemptionEventModel_Asset as the provided RedemptionEventModelAsset1
func (t *RedemptionEventModel_Asset) FromRedemptionEventModelAsset1(v RedemptionEventModelAsset1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRedemptionEventModelAsset1 performs a merge with any union data inside the RedemptionEventModel_Asset, using the provided RedemptionEventModelAsset1
func (t *RedemptionEventModel_Asset) MergeRedemptionEventModelAsset1(v RedemptionEventModelAsset1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t RedemptionEventModel_Asset) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *RedemptionEventModel_Asset) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsSerializedOrderComponentsCounter0 returns the union data inside the SerializedOrderComponents_Counter as a SerializedOrderComponentsCounter0
func (t SerializedOrderComponents_Counter) AsSerializedOrderComponentsCounter0() (SerializedOrderComponentsCounter0, error) {
	var body SerializedOrderComponentsCounter0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSerializedOrderComponentsCounter0 overwrites any union data inside the SerializedOrderComponents_Counter as the provided SerializedOrderComponentsCounter0
func (t *SerializedOrderComponents_Counter) FromSerializedOrderComponentsCounter0(v SerializedOrderComponentsCounter0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSerializedOrderComponentsCounter0 performs a merge with any union data inside the SerializedOrderComponents_Counter, using the provided SerializedOrderComponentsCounter0
func (t *SerializedOrderComponents_Counter) MergeSerializedOrderComponentsCounter0(v SerializedOrderComponentsCounter0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSerializedOrderComponentsCounter1 returns the union data inside the SerializedOrderComponents_Counter as a SerializedOrderComponentsCounter1
func (t SerializedOrderComponents_Counter) AsSerializedOrderComponentsCounter1() (SerializedOrderComponentsCounter1, error) {
	var body SerializedOrderComponentsCounter1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSerializedOrderComponentsCounter1 overwrites any union data inside the SerializedOrderComponents_Counter as the provided SerializedOrderComponentsCounter1
func (t *SerializedOrderComponents_Counter) FromSerializedOrderComponentsCounter1(v SerializedOrderComponentsCounter1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSerializedOrderComponentsCounter1 performs a merge with any union data inside the SerializedOrderComponents_Counter, using the provided SerializedOrderComponentsCounter1
func (t *SerializedOrderComponents_Counter) MergeSerializedOrderComponentsCounter1(v SerializedOrderComponentsCounter1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t SerializedOrderComponents_Counter) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *SerializedOrderComponents_Counter) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsTraitModelValue0 returns the union data inside the TraitModel_Value as a TraitModelValue0
func (t TraitModel_Value) AsTraitModelValue0() (TraitModelValue0, error) {
	var body TraitModelValue0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTraitModelValue0 overwrites any union data inside the TraitModel_Value as the provided TraitModelValue0
func (t *TraitModel_Value) FromTraitModelValue0(v TraitModelValue0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTraitModelValue0 performs a merge with any union data inside the TraitModel_Value, using the provided TraitModelValue0
func (t *TraitModel_Value) MergeTraitModelValue0(v TraitModelValue0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsTraitModelValue1 returns the union data inside the TraitModel_Value as a TraitModelValue1
func (t TraitModel_Value) AsTraitModelValue1() (TraitModelValue1, error) {
	var body TraitModelValue1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTraitModelValue1 overwrites any union data inside the TraitModel_Value as the provided TraitModelValue1
func (t *TraitModel_Value) FromTraitModelValue1(v TraitModelValue1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTraitModelValue1 performs a merge with any union data inside the TraitModel_Value, using the provided TraitModelValue1
func (t *TraitModel_Value) MergeTraitModelValue1(v TraitModelValue1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsTraitModelValue2 returns the union data inside the TraitModel_Value as a TraitModelValue2
func (t TraitModel_Value) AsTraitModelValue2() (TraitModelValue2, error) {
	var body TraitModelValue2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTraitModelValue2 overwrites any union data inside the TraitModel_Value as the provided TraitModelValue2
func (t *TraitModel_Value) FromTraitModelValue2(v TraitModelValue2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTraitModelValue2 performs a merge with any union data inside the TraitModel_Value, using the provided TraitModelValue2
func (t *TraitModel_Value) MergeTraitModelValue2(v TraitModelValue2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsTraitModelValue3 returns the union data inside the TraitModel_Value as a TraitModelValue3
func (t TraitModel_Value) AsTraitModelValue3() (TraitModelValue3, error) {
	var body TraitModelValue3
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTraitModelValue3 overwrites any union data inside the TraitModel_Value as the provided TraitModelValue3
func (t *TraitModel_Value) FromTraitModelValue3(v TraitModelValue3) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTraitModelValue3 performs a merge with any union data inside the TraitModel_Value, using the provided TraitModelValue3
func (t *TraitModel_Value) MergeTraitModelValue3(v TraitModelValue3) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t TraitModel_Value) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *TraitModel_Value) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetAccount request
	GetAccount(ctx context.Context, address string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListNftsByAccount request
	ListNftsByAccount(ctx context.Context, chain ListNftsByAccountParamsChain, address string, params *ListNftsByAccountParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetContract request
	GetContract(ctx context.Context, chain GetContractParamsChain, address string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListNftsByContract request
	ListNftsByContract(ctx context.Context, chain ListNftsByContractParamsChain, address string, params *ListNftsByContractParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNft request
	GetNft(ctx context.Context, chain GetNftParamsChain, address string, identifier string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RefreshNft request
	RefreshNft(ctx context.Context, chain RefreshNftParamsChain, address string, identifier string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListNftsByCollection request
	ListNftsByCollection(ctx context.Context, collectionSlug string, params *ListNftsByCollectionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListCollections request
	ListCollections(ctx context.Context, params *ListCollectionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCollection request
	GetCollection(ctx context.Context, collectionSlug string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCollectionStats request
	GetCollectionStats(ctx context.Context, collectionSlug string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListEventsByAccount request
	ListEventsByAccount(ctx context.Context, address string, params *ListEventsByAccountParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListEventsByNft request
	ListEventsByNft(ctx context.Context, chain ListEventsByNftParamsChain, address string, identifier string, params *ListEventsByNftParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListEventsByCollection request
	ListEventsByCollection(ctx context.Context, collectionSlug string, params *ListEventsByCollectionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllListingsOnCollectionV2 request
	GetAllListingsOnCollectionV2(ctx context.Context, collectionSlug string, params *GetAllListingsOnCollectionV2Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GenerateListingFulfillmentDataV2WithBody request with any body
	GenerateListingFulfillmentDataV2WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GenerateListingFulfillmentDataV2(ctx context.Context, body GenerateListingFulfillmentDataV2JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	GenerateListingFulfillmentDataV2WithFormdataBody(ctx context.Context, body GenerateListingFulfillmentDataV2FormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostCriteriaOfferV2WithBody request with any body
	PostCriteriaOfferV2WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostCriteriaOfferV2(ctx context.Context, body PostCriteriaOfferV2JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostCriteriaOfferV2WithFormdataBody(ctx context.Context, body PostCriteriaOfferV2FormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BuildOfferV2WithBody request with any body
	BuildOfferV2WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	BuildOfferV2(ctx context.Context, body BuildOfferV2JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	BuildOfferV2WithFormdataBody(ctx context.Context, body BuildOfferV2FormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCollectionOffersV2 request
	GetCollectionOffersV2(ctx context.Context, collectionSlug string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllOffersOnCollectionV2 request
	GetAllOffersOnCollectionV2(ctx context.Context, collectionSlug string, params *GetAllOffersOnCollectionV2Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTraitOffersV2 request
	GetTraitOffersV2(ctx context.Context, collectionSlug string, params *GetTraitOffersV2Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GenerateOfferFulfillmentDataV2WithBody request with any body
	GenerateOfferFulfillmentDataV2WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GenerateOfferFulfillmentDataV2(ctx context.Context, body GenerateOfferFulfillmentDataV2JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	GenerateOfferFulfillmentDataV2WithFormdataBody(ctx context.Context, body GenerateOfferFulfillmentDataV2FormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOrder request
	GetOrder(ctx context.Context, chain GetOrderParamsChain, protocolAddress GetOrderParamsProtocolAddress, orderHash string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetListings request
	GetListings(ctx context.Context, chain GetListingsParamsChain, protocol GetListingsParamsProtocol, params *GetListingsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostListingWithBody request with any body
	PostListingWithBody(ctx context.Context, chain PostListingParamsChain, protocol PostListingParamsProtocol, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostListing(ctx context.Context, chain PostListingParamsChain, protocol PostListingParamsProtocol, body PostListingJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostListingWithFormdataBody(ctx context.Context, chain PostListingParamsChain, protocol PostListingParamsProtocol, body PostListingFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOffers request
	GetOffers(ctx context.Context, chain GetOffersParamsChain, protocol GetOffersParamsProtocol, params *GetOffersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostOfferWithBody request with any body
	PostOfferWithBody(ctx context.Context, chain PostOfferParamsChain, protocol PostOfferParamsProtocol, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostOffer(ctx context.Context, chain PostOfferParamsChain, protocol PostOfferParamsProtocol, body PostOfferJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostOfferWithFormdataBody(ctx context.Context, chain PostOfferParamsChain, protocol PostOfferParamsProtocol, body PostOfferFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTraits request
	GetTraits(ctx context.Context, collectionSlug string, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetAccount(ctx context.Context, address string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAccountRequest(c.Server, address)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListNftsByAccount(ctx context.Context, chain ListNftsByAccountParamsChain, address string, params *ListNftsByAccountParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListNftsByAccountRequest(c.Server, chain, address, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetContract(ctx context.Context, chain GetContractParamsChain, address string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetContractRequest(c.Server, chain, address)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListNftsByContract(ctx context.Context, chain ListNftsByContractParamsChain, address string, params *ListNftsByContractParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListNftsByContractRequest(c.Server, chain, address, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNft(ctx context.Context, chain GetNftParamsChain, address string, identifier string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNftRequest(c.Server, chain, address, identifier)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RefreshNft(ctx context.Context, chain RefreshNftParamsChain, address string, identifier string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRefreshNftRequest(c.Server, chain, address, identifier)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListNftsByCollection(ctx context.Context, collectionSlug string, params *ListNftsByCollectionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListNftsByCollectionRequest(c.Server, collectionSlug, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListCollections(ctx context.Context, params *ListCollectionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListCollectionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCollection(ctx context.Context, collectionSlug string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCollectionRequest(c.Server, collectionSlug)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCollectionStats(ctx context.Context, collectionSlug string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCollectionStatsRequest(c.Server, collectionSlug)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListEventsByAccount(ctx context.Context, address string, params *ListEventsByAccountParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListEventsByAccountRequest(c.Server, address, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListEventsByNft(ctx context.Context, chain ListEventsByNftParamsChain, address string, identifier string, params *ListEventsByNftParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListEventsByNftRequest(c.Server, chain, address, identifier, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListEventsByCollection(ctx context.Context, collectionSlug string, params *ListEventsByCollectionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListEventsByCollectionRequest(c.Server, collectionSlug, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllListingsOnCollectionV2(ctx context.Context, collectionSlug string, params *GetAllListingsOnCollectionV2Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllListingsOnCollectionV2Request(c.Server, collectionSlug, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GenerateListingFulfillmentDataV2WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGenerateListingFulfillmentDataV2RequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GenerateListingFulfillmentDataV2(ctx context.Context, body GenerateListingFulfillmentDataV2JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGenerateListingFulfillmentDataV2Request(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GenerateListingFulfillmentDataV2WithFormdataBody(ctx context.Context, body GenerateListingFulfillmentDataV2FormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGenerateListingFulfillmentDataV2RequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostCriteriaOfferV2WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostCriteriaOfferV2RequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostCriteriaOfferV2(ctx context.Context, body PostCriteriaOfferV2JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostCriteriaOfferV2Request(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostCriteriaOfferV2WithFormdataBody(ctx context.Context, body PostCriteriaOfferV2FormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostCriteriaOfferV2RequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BuildOfferV2WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBuildOfferV2RequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BuildOfferV2(ctx context.Context, body BuildOfferV2JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBuildOfferV2Request(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BuildOfferV2WithFormdataBody(ctx context.Context, body BuildOfferV2FormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBuildOfferV2RequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCollectionOffersV2(ctx context.Context, collectionSlug string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCollectionOffersV2Request(c.Server, collectionSlug)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllOffersOnCollectionV2(ctx context.Context, collectionSlug string, params *GetAllOffersOnCollectionV2Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllOffersOnCollectionV2Request(c.Server, collectionSlug, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTraitOffersV2(ctx context.Context, collectionSlug string, params *GetTraitOffersV2Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTraitOffersV2Request(c.Server, collectionSlug, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GenerateOfferFulfillmentDataV2WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGenerateOfferFulfillmentDataV2RequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GenerateOfferFulfillmentDataV2(ctx context.Context, body GenerateOfferFulfillmentDataV2JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGenerateOfferFulfillmentDataV2Request(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GenerateOfferFulfillmentDataV2WithFormdataBody(ctx context.Context, body GenerateOfferFulfillmentDataV2FormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGenerateOfferFulfillmentDataV2RequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOrder(ctx context.Context, chain GetOrderParamsChain, protocolAddress GetOrderParamsProtocolAddress, orderHash string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOrderRequest(c.Server, chain, protocolAddress, orderHash)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetListings(ctx context.Context, chain GetListingsParamsChain, protocol GetListingsParamsProtocol, params *GetListingsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetListingsRequest(c.Server, chain, protocol, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostListingWithBody(ctx context.Context, chain PostListingParamsChain, protocol PostListingParamsProtocol, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostListingRequestWithBody(c.Server, chain, protocol, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostListing(ctx context.Context, chain PostListingParamsChain, protocol PostListingParamsProtocol, body PostListingJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostListingRequest(c.Server, chain, protocol, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostListingWithFormdataBody(ctx context.Context, chain PostListingParamsChain, protocol PostListingParamsProtocol, body PostListingFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostListingRequestWithFormdataBody(c.Server, chain, protocol, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOffers(ctx context.Context, chain GetOffersParamsChain, protocol GetOffersParamsProtocol, params *GetOffersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOffersRequest(c.Server, chain, protocol, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostOfferWithBody(ctx context.Context, chain PostOfferParamsChain, protocol PostOfferParamsProtocol, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostOfferRequestWithBody(c.Server, chain, protocol, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostOffer(ctx context.Context, chain PostOfferParamsChain, protocol PostOfferParamsProtocol, body PostOfferJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostOfferRequest(c.Server, chain, protocol, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostOfferWithFormdataBody(ctx context.Context, chain PostOfferParamsChain, protocol PostOfferParamsProtocol, body PostOfferFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostOfferRequestWithFormdataBody(c.Server, chain, protocol, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTraits(ctx context.Context, collectionSlug string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTraitsRequest(c.Server, collectionSlug)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetAccountRequest generates requests for GetAccount
func NewGetAccountRequest(server string, address string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "address", runtime.ParamLocationPath, address)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/accounts/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListNftsByAccountRequest generates requests for ListNftsByAccount
func NewListNftsByAccountRequest(server string, chain ListNftsByAccountParamsChain, address string, params *ListNftsByAccountParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "chain", runtime.ParamLocationPath, chain)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "address", runtime.ParamLocationPath, address)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/chain/%s/account/%s/nfts", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Collection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "collection", runtime.ParamLocationQuery, *params.Collection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Next != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "next", runtime.ParamLocationQuery, *params.Next); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetContractRequest generates requests for GetContract
func NewGetContractRequest(server string, chain GetContractParamsChain, address string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "chain", runtime.ParamLocationPath, chain)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "address", runtime.ParamLocationPath, address)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/chain/%s/contract/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListNftsByContractRequest generates requests for ListNftsByContract
func NewListNftsByContractRequest(server string, chain ListNftsByContractParamsChain, address string, params *ListNftsByContractParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "chain", runtime.ParamLocationPath, chain)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "address", runtime.ParamLocationPath, address)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/chain/%s/contract/%s/nfts", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Next != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "next", runtime.ParamLocationQuery, *params.Next); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetNftRequest generates requests for GetNft
func NewGetNftRequest(server string, chain GetNftParamsChain, address string, identifier string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "chain", runtime.ParamLocationPath, chain)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "address", runtime.ParamLocationPath, address)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "identifier", runtime.ParamLocationPath, identifier)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/chain/%s/contract/%s/nfts/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRefreshNftRequest generates requests for RefreshNft
func NewRefreshNftRequest(server string, chain RefreshNftParamsChain, address string, identifier string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "chain", runtime.ParamLocationPath, chain)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "address", runtime.ParamLocationPath, address)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "identifier", runtime.ParamLocationPath, identifier)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/chain/%s/contract/%s/nfts/%s/refresh", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListNftsByCollectionRequest generates requests for ListNftsByCollection
func NewListNftsByCollectionRequest(server string, collectionSlug string, params *ListNftsByCollectionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "collection_slug", runtime.ParamLocationPath, collectionSlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/collection/%s/nfts", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Next != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "next", runtime.ParamLocationQuery, *params.Next); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListCollectionsRequest generates requests for ListCollections
func NewListCollectionsRequest(server string, params *ListCollectionsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/collections")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ChainIdentifier != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "chain_identifier", runtime.ParamLocationQuery, *params.ChainIdentifier); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeHidden != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_hidden", runtime.ParamLocationQuery, *params.IncludeHidden); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Next != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "next", runtime.ParamLocationQuery, *params.Next); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCollectionRequest generates requests for GetCollection
func NewGetCollectionRequest(server string, collectionSlug string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "collection_slug", runtime.ParamLocationPath, collectionSlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/collections/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCollectionStatsRequest generates requests for GetCollectionStats
func NewGetCollectionStatsRequest(server string, collectionSlug string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "collection_slug", runtime.ParamLocationPath, collectionSlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/collections/%s/stats", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListEventsByAccountRequest generates requests for ListEventsByAccount
func NewListEventsByAccountRequest(server string, address string, params *ListEventsByAccountParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "address", runtime.ParamLocationPath, address)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/events/accounts/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.After != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Before != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "before", runtime.ParamLocationQuery, *params.Before); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Chain != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "chain", runtime.ParamLocationQuery, *params.Chain); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EventType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "event_type", runtime.ParamLocationQuery, *params.EventType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Next != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "next", runtime.ParamLocationQuery, *params.Next); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListEventsByNftRequest generates requests for ListEventsByNft
func NewListEventsByNftRequest(server string, chain ListEventsByNftParamsChain, address string, identifier string, params *ListEventsByNftParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "chain", runtime.ParamLocationPath, chain)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "address", runtime.ParamLocationPath, address)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "identifier", runtime.ParamLocationPath, identifier)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/events/chain/%s/contract/%s/nfts/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.After != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Before != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "before", runtime.ParamLocationQuery, *params.Before); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EventType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "event_type", runtime.ParamLocationQuery, *params.EventType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Next != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "next", runtime.ParamLocationQuery, *params.Next); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListEventsByCollectionRequest generates requests for ListEventsByCollection
func NewListEventsByCollectionRequest(server string, collectionSlug string, params *ListEventsByCollectionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "collection_slug", runtime.ParamLocationPath, collectionSlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/events/collection/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.After != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Before != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "before", runtime.ParamLocationQuery, *params.Before); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EventType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "event_type", runtime.ParamLocationQuery, *params.EventType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Next != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "next", runtime.ParamLocationQuery, *params.Next); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAllListingsOnCollectionV2Request generates requests for GetAllListingsOnCollectionV2
func NewGetAllListingsOnCollectionV2Request(server string, collectionSlug string, params *GetAllListingsOnCollectionV2Params) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "collection_slug", runtime.ParamLocationPath, collectionSlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/listings/collection/%s/all", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Next != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "next", runtime.ParamLocationQuery, *params.Next); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGenerateListingFulfillmentDataV2Request calls the generic GenerateListingFulfillmentDataV2 builder with application/json body
func NewGenerateListingFulfillmentDataV2Request(server string, body GenerateListingFulfillmentDataV2JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGenerateListingFulfillmentDataV2RequestWithBody(server, "application/json", bodyReader)
}

// NewGenerateListingFulfillmentDataV2RequestWithFormdataBody calls the generic GenerateListingFulfillmentDataV2 builder with application/x-www-form-urlencoded body
func NewGenerateListingFulfillmentDataV2RequestWithFormdataBody(server string, body GenerateListingFulfillmentDataV2FormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewGenerateListingFulfillmentDataV2RequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewGenerateListingFulfillmentDataV2RequestWithBody generates requests for GenerateListingFulfillmentDataV2 with any type of body
func NewGenerateListingFulfillmentDataV2RequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/listings/fulfillment_data")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostCriteriaOfferV2Request calls the generic PostCriteriaOfferV2 builder with application/json body
func NewPostCriteriaOfferV2Request(server string, body PostCriteriaOfferV2JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostCriteriaOfferV2RequestWithBody(server, "application/json", bodyReader)
}

// NewPostCriteriaOfferV2RequestWithFormdataBody calls the generic PostCriteriaOfferV2 builder with application/x-www-form-urlencoded body
func NewPostCriteriaOfferV2RequestWithFormdataBody(server string, body PostCriteriaOfferV2FormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewPostCriteriaOfferV2RequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewPostCriteriaOfferV2RequestWithBody generates requests for PostCriteriaOfferV2 with any type of body
func NewPostCriteriaOfferV2RequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/offers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewBuildOfferV2Request calls the generic BuildOfferV2 builder with application/json body
func NewBuildOfferV2Request(server string, body BuildOfferV2JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewBuildOfferV2RequestWithBody(server, "application/json", bodyReader)
}

// NewBuildOfferV2RequestWithFormdataBody calls the generic BuildOfferV2 builder with application/x-www-form-urlencoded body
func NewBuildOfferV2RequestWithFormdataBody(server string, body BuildOfferV2FormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewBuildOfferV2RequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewBuildOfferV2RequestWithBody generates requests for BuildOfferV2 with any type of body
func NewBuildOfferV2RequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/offers/build")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetCollectionOffersV2Request generates requests for GetCollectionOffersV2
func NewGetCollectionOffersV2Request(server string, collectionSlug string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "collection_slug", runtime.ParamLocationPath, collectionSlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/offers/collection/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAllOffersOnCollectionV2Request generates requests for GetAllOffersOnCollectionV2
func NewGetAllOffersOnCollectionV2Request(server string, collectionSlug string, params *GetAllOffersOnCollectionV2Params) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "collection_slug", runtime.ParamLocationPath, collectionSlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/offers/collection/%s/all", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Next != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "next", runtime.ParamLocationQuery, *params.Next); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTraitOffersV2Request generates requests for GetTraitOffersV2
func NewGetTraitOffersV2Request(server string, collectionSlug string, params *GetTraitOffersV2Params) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "collection_slug", runtime.ParamLocationPath, collectionSlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/offers/collection/%s/traits", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.FloatValue != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "float_value", runtime.ParamLocationQuery, *params.FloatValue); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IntValue != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "int_value", runtime.ParamLocationQuery, *params.IntValue); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Value != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "value", runtime.ParamLocationQuery, *params.Value); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGenerateOfferFulfillmentDataV2Request calls the generic GenerateOfferFulfillmentDataV2 builder with application/json body
func NewGenerateOfferFulfillmentDataV2Request(server string, body GenerateOfferFulfillmentDataV2JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGenerateOfferFulfillmentDataV2RequestWithBody(server, "application/json", bodyReader)
}

// NewGenerateOfferFulfillmentDataV2RequestWithFormdataBody calls the generic GenerateOfferFulfillmentDataV2 builder with application/x-www-form-urlencoded body
func NewGenerateOfferFulfillmentDataV2RequestWithFormdataBody(server string, body GenerateOfferFulfillmentDataV2FormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewGenerateOfferFulfillmentDataV2RequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewGenerateOfferFulfillmentDataV2RequestWithBody generates requests for GenerateOfferFulfillmentDataV2 with any type of body
func NewGenerateOfferFulfillmentDataV2RequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/offers/fulfillment_data")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetOrderRequest generates requests for GetOrder
func NewGetOrderRequest(server string, chain GetOrderParamsChain, protocolAddress GetOrderParamsProtocolAddress, orderHash string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "chain", runtime.ParamLocationPath, chain)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "protocol_address", runtime.ParamLocationPath, protocolAddress)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "order_hash", runtime.ParamLocationPath, orderHash)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/orders/chain/%s/protocol/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetListingsRequest generates requests for GetListings
func NewGetListingsRequest(server string, chain GetListingsParamsChain, protocol GetListingsParamsProtocol, params *GetListingsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "chain", runtime.ParamLocationPath, chain)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "protocol", runtime.ParamLocationPath, protocol)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/orders/%s/%s/listings", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AssetContractAddress != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "asset_contract_address", runtime.ParamLocationQuery, *params.AssetContractAddress); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Bundled != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "bundled", runtime.ParamLocationQuery, *params.Bundled); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ListedAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "listed_after", runtime.ParamLocationQuery, *params.ListedAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ListedBefore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "listed_before", runtime.ParamLocationQuery, *params.ListedBefore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Maker != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maker", runtime.ParamLocationQuery, *params.Maker); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order_by", runtime.ParamLocationQuery, *params.OrderBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderDirection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order_direction", runtime.ParamLocationQuery, *params.OrderDirection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PaymentTokenAddress != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "payment_token_address", runtime.ParamLocationQuery, *params.PaymentTokenAddress); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Taker != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "taker", runtime.ParamLocationQuery, *params.Taker); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TokenIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "token_ids", runtime.ParamLocationQuery, *params.TokenIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostListingRequest calls the generic PostListing builder with application/json body
func NewPostListingRequest(server string, chain PostListingParamsChain, protocol PostListingParamsProtocol, body PostListingJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostListingRequestWithBody(server, chain, protocol, "application/json", bodyReader)
}

// NewPostListingRequestWithFormdataBody calls the generic PostListing builder with application/x-www-form-urlencoded body
func NewPostListingRequestWithFormdataBody(server string, chain PostListingParamsChain, protocol PostListingParamsProtocol, body PostListingFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewPostListingRequestWithBody(server, chain, protocol, "application/x-www-form-urlencoded", bodyReader)
}

// NewPostListingRequestWithBody generates requests for PostListing with any type of body
func NewPostListingRequestWithBody(server string, chain PostListingParamsChain, protocol PostListingParamsProtocol, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "chain", runtime.ParamLocationPath, chain)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "protocol", runtime.ParamLocationPath, protocol)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/orders/%s/%s/listings", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetOffersRequest generates requests for GetOffers
func NewGetOffersRequest(server string, chain GetOffersParamsChain, protocol GetOffersParamsProtocol, params *GetOffersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "chain", runtime.ParamLocationPath, chain)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "protocol", runtime.ParamLocationPath, protocol)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/orders/%s/%s/offers", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AssetContractAddress != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "asset_contract_address", runtime.ParamLocationQuery, *params.AssetContractAddress); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Bundled != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "bundled", runtime.ParamLocationQuery, *params.Bundled); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ListedAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "listed_after", runtime.ParamLocationQuery, *params.ListedAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ListedBefore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "listed_before", runtime.ParamLocationQuery, *params.ListedBefore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Maker != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maker", runtime.ParamLocationQuery, *params.Maker); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order_by", runtime.ParamLocationQuery, *params.OrderBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderDirection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order_direction", runtime.ParamLocationQuery, *params.OrderDirection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PaymentTokenAddress != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "payment_token_address", runtime.ParamLocationQuery, *params.PaymentTokenAddress); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Taker != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "taker", runtime.ParamLocationQuery, *params.Taker); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TokenIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "token_ids", runtime.ParamLocationQuery, *params.TokenIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostOfferRequest calls the generic PostOffer builder with application/json body
func NewPostOfferRequest(server string, chain PostOfferParamsChain, protocol PostOfferParamsProtocol, body PostOfferJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostOfferRequestWithBody(server, chain, protocol, "application/json", bodyReader)
}

// NewPostOfferRequestWithFormdataBody calls the generic PostOffer builder with application/x-www-form-urlencoded body
func NewPostOfferRequestWithFormdataBody(server string, chain PostOfferParamsChain, protocol PostOfferParamsProtocol, body PostOfferFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewPostOfferRequestWithBody(server, chain, protocol, "application/x-www-form-urlencoded", bodyReader)
}

// NewPostOfferRequestWithBody generates requests for PostOffer with any type of body
func NewPostOfferRequestWithBody(server string, chain PostOfferParamsChain, protocol PostOfferParamsProtocol, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "chain", runtime.ParamLocationPath, chain)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "protocol", runtime.ParamLocationPath, protocol)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/orders/%s/%s/offers", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetTraitsRequest generates requests for GetTraits
func NewGetTraitsRequest(server string, collectionSlug string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "collection_slug", runtime.ParamLocationPath, collectionSlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/traits/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetAccountWithResponse request
	GetAccountWithResponse(ctx context.Context, address string, reqEditors ...RequestEditorFn) (*GetAccountRes, error)

	// ListNftsByAccountWithResponse request
	ListNftsByAccountWithResponse(ctx context.Context, chain ListNftsByAccountParamsChain, address string, params *ListNftsByAccountParams, reqEditors ...RequestEditorFn) (*ListNftsByAccountRes, error)

	// GetContractWithResponse request
	GetContractWithResponse(ctx context.Context, chain GetContractParamsChain, address string, reqEditors ...RequestEditorFn) (*GetContractRes, error)

	// ListNftsByContractWithResponse request
	ListNftsByContractWithResponse(ctx context.Context, chain ListNftsByContractParamsChain, address string, params *ListNftsByContractParams, reqEditors ...RequestEditorFn) (*ListNftsByContractRes, error)

	// GetNftWithResponse request
	GetNftWithResponse(ctx context.Context, chain GetNftParamsChain, address string, identifier string, reqEditors ...RequestEditorFn) (*GetNftRes, error)

	// RefreshNftWithResponse request
	RefreshNftWithResponse(ctx context.Context, chain RefreshNftParamsChain, address string, identifier string, reqEditors ...RequestEditorFn) (*RefreshNftRes, error)

	// ListNftsByCollectionWithResponse request
	ListNftsByCollectionWithResponse(ctx context.Context, collectionSlug string, params *ListNftsByCollectionParams, reqEditors ...RequestEditorFn) (*ListNftsByCollectionRes, error)

	// ListCollectionsWithResponse request
	ListCollectionsWithResponse(ctx context.Context, params *ListCollectionsParams, reqEditors ...RequestEditorFn) (*ListCollectionsRes, error)

	// GetCollectionWithResponse request
	GetCollectionWithResponse(ctx context.Context, collectionSlug string, reqEditors ...RequestEditorFn) (*GetCollectionRes, error)

	// GetCollectionStatsWithResponse request
	GetCollectionStatsWithResponse(ctx context.Context, collectionSlug string, reqEditors ...RequestEditorFn) (*GetCollectionStatsRes, error)

	// ListEventsByAccountWithResponse request
	ListEventsByAccountWithResponse(ctx context.Context, address string, params *ListEventsByAccountParams, reqEditors ...RequestEditorFn) (*ListEventsByAccountRes, error)

	// ListEventsByNftWithResponse request
	ListEventsByNftWithResponse(ctx context.Context, chain ListEventsByNftParamsChain, address string, identifier string, params *ListEventsByNftParams, reqEditors ...RequestEditorFn) (*ListEventsByNftRes, error)

	// ListEventsByCollectionWithResponse request
	ListEventsByCollectionWithResponse(ctx context.Context, collectionSlug string, params *ListEventsByCollectionParams, reqEditors ...RequestEditorFn) (*ListEventsByCollectionRes, error)

	// GetAllListingsOnCollectionV2WithResponse request
	GetAllListingsOnCollectionV2WithResponse(ctx context.Context, collectionSlug string, params *GetAllListingsOnCollectionV2Params, reqEditors ...RequestEditorFn) (*GetAllListingsOnCollectionV2Res, error)

	// GenerateListingFulfillmentDataV2WithBodyWithResponse request with any body
	GenerateListingFulfillmentDataV2WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GenerateListingFulfillmentDataV2Res, error)

	GenerateListingFulfillmentDataV2WithResponse(ctx context.Context, body GenerateListingFulfillmentDataV2JSONRequestBody, reqEditors ...RequestEditorFn) (*GenerateListingFulfillmentDataV2Res, error)

	GenerateListingFulfillmentDataV2WithFormdataBodyWithResponse(ctx context.Context, body GenerateListingFulfillmentDataV2FormdataRequestBody, reqEditors ...RequestEditorFn) (*GenerateListingFulfillmentDataV2Res, error)

	// PostCriteriaOfferV2WithBodyWithResponse request with any body
	PostCriteriaOfferV2WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostCriteriaOfferV2Res, error)

	PostCriteriaOfferV2WithResponse(ctx context.Context, body PostCriteriaOfferV2JSONRequestBody, reqEditors ...RequestEditorFn) (*PostCriteriaOfferV2Res, error)

	PostCriteriaOfferV2WithFormdataBodyWithResponse(ctx context.Context, body PostCriteriaOfferV2FormdataRequestBody, reqEditors ...RequestEditorFn) (*PostCriteriaOfferV2Res, error)

	// BuildOfferV2WithBodyWithResponse request with any body
	BuildOfferV2WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BuildOfferV2Res, error)

	BuildOfferV2WithResponse(ctx context.Context, body BuildOfferV2JSONRequestBody, reqEditors ...RequestEditorFn) (*BuildOfferV2Res, error)

	BuildOfferV2WithFormdataBodyWithResponse(ctx context.Context, body BuildOfferV2FormdataRequestBody, reqEditors ...RequestEditorFn) (*BuildOfferV2Res, error)

	// GetCollectionOffersV2WithResponse request
	GetCollectionOffersV2WithResponse(ctx context.Context, collectionSlug string, reqEditors ...RequestEditorFn) (*GetCollectionOffersV2Res, error)

	// GetAllOffersOnCollectionV2WithResponse request
	GetAllOffersOnCollectionV2WithResponse(ctx context.Context, collectionSlug string, params *GetAllOffersOnCollectionV2Params, reqEditors ...RequestEditorFn) (*GetAllOffersOnCollectionV2Res, error)

	// GetTraitOffersV2WithResponse request
	GetTraitOffersV2WithResponse(ctx context.Context, collectionSlug string, params *GetTraitOffersV2Params, reqEditors ...RequestEditorFn) (*GetTraitOffersV2Res, error)

	// GenerateOfferFulfillmentDataV2WithBodyWithResponse request with any body
	GenerateOfferFulfillmentDataV2WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GenerateOfferFulfillmentDataV2Res, error)

	GenerateOfferFulfillmentDataV2WithResponse(ctx context.Context, body GenerateOfferFulfillmentDataV2JSONRequestBody, reqEditors ...RequestEditorFn) (*GenerateOfferFulfillmentDataV2Res, error)

	GenerateOfferFulfillmentDataV2WithFormdataBodyWithResponse(ctx context.Context, body GenerateOfferFulfillmentDataV2FormdataRequestBody, reqEditors ...RequestEditorFn) (*GenerateOfferFulfillmentDataV2Res, error)

	// GetOrderWithResponse request
	GetOrderWithResponse(ctx context.Context, chain GetOrderParamsChain, protocolAddress GetOrderParamsProtocolAddress, orderHash string, reqEditors ...RequestEditorFn) (*GetOrderRes, error)

	// GetListingsWithResponse request
	GetListingsWithResponse(ctx context.Context, chain GetListingsParamsChain, protocol GetListingsParamsProtocol, params *GetListingsParams, reqEditors ...RequestEditorFn) (*GetListingsRes, error)

	// PostListingWithBodyWithResponse request with any body
	PostListingWithBodyWithResponse(ctx context.Context, chain PostListingParamsChain, protocol PostListingParamsProtocol, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostListingRes, error)

	PostListingWithResponse(ctx context.Context, chain PostListingParamsChain, protocol PostListingParamsProtocol, body PostListingJSONRequestBody, reqEditors ...RequestEditorFn) (*PostListingRes, error)

	PostListingWithFormdataBodyWithResponse(ctx context.Context, chain PostListingParamsChain, protocol PostListingParamsProtocol, body PostListingFormdataRequestBody, reqEditors ...RequestEditorFn) (*PostListingRes, error)

	// GetOffersWithResponse request
	GetOffersWithResponse(ctx context.Context, chain GetOffersParamsChain, protocol GetOffersParamsProtocol, params *GetOffersParams, reqEditors ...RequestEditorFn) (*GetOffersRes, error)

	// PostOfferWithBodyWithResponse request with any body
	PostOfferWithBodyWithResponse(ctx context.Context, chain PostOfferParamsChain, protocol PostOfferParamsProtocol, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostOfferRes, error)

	PostOfferWithResponse(ctx context.Context, chain PostOfferParamsChain, protocol PostOfferParamsProtocol, body PostOfferJSONRequestBody, reqEditors ...RequestEditorFn) (*PostOfferRes, error)

	PostOfferWithFormdataBodyWithResponse(ctx context.Context, chain PostOfferParamsChain, protocol PostOfferParamsProtocol, body PostOfferFormdataRequestBody, reqEditors ...RequestEditorFn) (*PostOfferRes, error)

	// GetTraitsWithResponse request
	GetTraitsWithResponse(ctx context.Context, collectionSlug string, reqEditors ...RequestEditorFn) (*GetTraitsRes, error)
}

type GetAccountRes struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DetailedAccountDataModel
}

// Status returns HTTPResponse.Status
func (r GetAccountRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAccountRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListNftsByAccountRes struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListNftsResponse
}

// Status returns HTTPResponse.Status
func (r ListNftsByAccountRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListNftsByAccountRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetContractRes struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListNftsResponse
}

// Status returns HTTPResponse.Status
func (r GetContractRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetContractRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListNftsByContractRes struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListNftsResponse
}

// Status returns HTTPResponse.Status
func (r ListNftsByContractRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListNftsByContractRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNftRes struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetNftResponse
}

// Status returns HTTPResponse.Status
func (r GetNftRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNftRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RefreshNftRes struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RefreshNftRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RefreshNftRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListNftsByCollectionRes struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListNftsResponse
}

// Status returns HTTPResponse.Status
func (r ListNftsByCollectionRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListNftsByCollectionRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListCollectionsRes struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListCollectionsResponse
}

// Status returns HTTPResponse.Status
func (r ListCollectionsRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListCollectionsRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCollectionRes struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DetailedCollectionModel
}

// Status returns HTTPResponse.Status
func (r GetCollectionRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCollectionRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCollectionStatsRes struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetCollectionStatsResponse
}

// Status returns HTTPResponse.Status
func (r GetCollectionStatsRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCollectionStatsRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListEventsByAccountRes struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListEventsResponse
}

// Status returns HTTPResponse.Status
func (r ListEventsByAccountRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListEventsByAccountRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListEventsByNftRes struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListEventsResponse
}

// Status returns HTTPResponse.Status
func (r ListEventsByNftRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListEventsByNftRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListEventsByCollectionRes struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListEventsResponse
}

// Status returns HTTPResponse.Status
func (r ListEventsByCollectionRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListEventsByCollectionRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllListingsOnCollectionV2Res struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaginatedListingList
}

// Status returns HTTPResponse.Status
func (r GetAllListingsOnCollectionV2Res) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllListingsOnCollectionV2Res) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GenerateListingFulfillmentDataV2Res struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FulfillmentOutput
}

// Status returns HTTPResponse.Status
func (r GenerateListingFulfillmentDataV2Res) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GenerateListingFulfillmentDataV2Res) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostCriteriaOfferV2Res struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Offer
}

// Status returns HTTPResponse.Status
func (r PostCriteriaOfferV2Res) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostCriteriaOfferV2Res) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BuildOfferV2Res struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BuildOffer
}

// Status returns HTTPResponse.Status
func (r BuildOfferV2Res) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BuildOfferV2Res) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCollectionOffersV2Res struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OfferList
}

// Status returns HTTPResponse.Status
func (r GetCollectionOffersV2Res) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCollectionOffersV2Res) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllOffersOnCollectionV2Res struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaginatedOfferList
}

// Status returns HTTPResponse.Status
func (r GetAllOffersOnCollectionV2Res) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllOffersOnCollectionV2Res) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTraitOffersV2Res struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OfferList
}

// Status returns HTTPResponse.Status
func (r GetTraitOffersV2Res) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTraitOffersV2Res) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GenerateOfferFulfillmentDataV2Res struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FulfillmentOutput
}

// Status returns HTTPResponse.Status
func (r GenerateOfferFulfillmentDataV2Res) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GenerateOfferFulfillmentDataV2Res) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOrderRes struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetOrderResult
}

// Status returns HTTPResponse.Status
func (r GetOrderRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOrderRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetListingsRes struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetListingsResponse
}

// Status returns HTTPResponse.Status
func (r GetListingsRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetListingsRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostListingRes struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CreateListingResponse
}

// Status returns HTTPResponse.Status
func (r PostListingRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostListingRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOffersRes struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetOfferResponse
}

// Status returns HTTPResponse.Status
func (r GetOffersRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOffersRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostOfferRes struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CreateOfferResponse
}

// Status returns HTTPResponse.Status
func (r PostOfferRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostOfferRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTraitsRes struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetTraitResponse
}

// Status returns HTTPResponse.Status
func (r GetTraitsRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTraitsRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetAccountWithResponse request returning *GetAccountRes
func (c *ClientWithResponses) GetAccountWithResponse(ctx context.Context, address string, reqEditors ...RequestEditorFn) (*GetAccountRes, error) {
	rsp, err := c.GetAccount(ctx, address, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAccountRes(rsp)
}

// ListNftsByAccountWithResponse request returning *ListNftsByAccountRes
func (c *ClientWithResponses) ListNftsByAccountWithResponse(ctx context.Context, chain ListNftsByAccountParamsChain, address string, params *ListNftsByAccountParams, reqEditors ...RequestEditorFn) (*ListNftsByAccountRes, error) {
	rsp, err := c.ListNftsByAccount(ctx, chain, address, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListNftsByAccountRes(rsp)
}

// GetContractWithResponse request returning *GetContractRes
func (c *ClientWithResponses) GetContractWithResponse(ctx context.Context, chain GetContractParamsChain, address string, reqEditors ...RequestEditorFn) (*GetContractRes, error) {
	rsp, err := c.GetContract(ctx, chain, address, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetContractRes(rsp)
}

// ListNftsByContractWithResponse request returning *ListNftsByContractRes
func (c *ClientWithResponses) ListNftsByContractWithResponse(ctx context.Context, chain ListNftsByContractParamsChain, address string, params *ListNftsByContractParams, reqEditors ...RequestEditorFn) (*ListNftsByContractRes, error) {
	rsp, err := c.ListNftsByContract(ctx, chain, address, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListNftsByContractRes(rsp)
}

// GetNftWithResponse request returning *GetNftRes
func (c *ClientWithResponses) GetNftWithResponse(ctx context.Context, chain GetNftParamsChain, address string, identifier string, reqEditors ...RequestEditorFn) (*GetNftRes, error) {
	rsp, err := c.GetNft(ctx, chain, address, identifier, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNftRes(rsp)
}

// RefreshNftWithResponse request returning *RefreshNftRes
func (c *ClientWithResponses) RefreshNftWithResponse(ctx context.Context, chain RefreshNftParamsChain, address string, identifier string, reqEditors ...RequestEditorFn) (*RefreshNftRes, error) {
	rsp, err := c.RefreshNft(ctx, chain, address, identifier, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRefreshNftRes(rsp)
}

// ListNftsByCollectionWithResponse request returning *ListNftsByCollectionRes
func (c *ClientWithResponses) ListNftsByCollectionWithResponse(ctx context.Context, collectionSlug string, params *ListNftsByCollectionParams, reqEditors ...RequestEditorFn) (*ListNftsByCollectionRes, error) {
	rsp, err := c.ListNftsByCollection(ctx, collectionSlug, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListNftsByCollectionRes(rsp)
}

// ListCollectionsWithResponse request returning *ListCollectionsRes
func (c *ClientWithResponses) ListCollectionsWithResponse(ctx context.Context, params *ListCollectionsParams, reqEditors ...RequestEditorFn) (*ListCollectionsRes, error) {
	rsp, err := c.ListCollections(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListCollectionsRes(rsp)
}

// GetCollectionWithResponse request returning *GetCollectionRes
func (c *ClientWithResponses) GetCollectionWithResponse(ctx context.Context, collectionSlug string, reqEditors ...RequestEditorFn) (*GetCollectionRes, error) {
	rsp, err := c.GetCollection(ctx, collectionSlug, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCollectionRes(rsp)
}

// GetCollectionStatsWithResponse request returning *GetCollectionStatsRes
func (c *ClientWithResponses) GetCollectionStatsWithResponse(ctx context.Context, collectionSlug string, reqEditors ...RequestEditorFn) (*GetCollectionStatsRes, error) {
	rsp, err := c.GetCollectionStats(ctx, collectionSlug, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCollectionStatsRes(rsp)
}

// ListEventsByAccountWithResponse request returning *ListEventsByAccountRes
func (c *ClientWithResponses) ListEventsByAccountWithResponse(ctx context.Context, address string, params *ListEventsByAccountParams, reqEditors ...RequestEditorFn) (*ListEventsByAccountRes, error) {
	rsp, err := c.ListEventsByAccount(ctx, address, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListEventsByAccountRes(rsp)
}

// ListEventsByNftWithResponse request returning *ListEventsByNftRes
func (c *ClientWithResponses) ListEventsByNftWithResponse(ctx context.Context, chain ListEventsByNftParamsChain, address string, identifier string, params *ListEventsByNftParams, reqEditors ...RequestEditorFn) (*ListEventsByNftRes, error) {
	rsp, err := c.ListEventsByNft(ctx, chain, address, identifier, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListEventsByNftRes(rsp)
}

// ListEventsByCollectionWithResponse request returning *ListEventsByCollectionRes
func (c *ClientWithResponses) ListEventsByCollectionWithResponse(ctx context.Context, collectionSlug string, params *ListEventsByCollectionParams, reqEditors ...RequestEditorFn) (*ListEventsByCollectionRes, error) {
	rsp, err := c.ListEventsByCollection(ctx, collectionSlug, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListEventsByCollectionRes(rsp)
}

// GetAllListingsOnCollectionV2WithResponse request returning *GetAllListingsOnCollectionV2Res
func (c *ClientWithResponses) GetAllListingsOnCollectionV2WithResponse(ctx context.Context, collectionSlug string, params *GetAllListingsOnCollectionV2Params, reqEditors ...RequestEditorFn) (*GetAllListingsOnCollectionV2Res, error) {
	rsp, err := c.GetAllListingsOnCollectionV2(ctx, collectionSlug, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllListingsOnCollectionV2Res(rsp)
}

// GenerateListingFulfillmentDataV2WithBodyWithResponse request with arbitrary body returning *GenerateListingFulfillmentDataV2Res
func (c *ClientWithResponses) GenerateListingFulfillmentDataV2WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GenerateListingFulfillmentDataV2Res, error) {
	rsp, err := c.GenerateListingFulfillmentDataV2WithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGenerateListingFulfillmentDataV2Res(rsp)
}

func (c *ClientWithResponses) GenerateListingFulfillmentDataV2WithResponse(ctx context.Context, body GenerateListingFulfillmentDataV2JSONRequestBody, reqEditors ...RequestEditorFn) (*GenerateListingFulfillmentDataV2Res, error) {
	rsp, err := c.GenerateListingFulfillmentDataV2(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGenerateListingFulfillmentDataV2Res(rsp)
}

func (c *ClientWithResponses) GenerateListingFulfillmentDataV2WithFormdataBodyWithResponse(ctx context.Context, body GenerateListingFulfillmentDataV2FormdataRequestBody, reqEditors ...RequestEditorFn) (*GenerateListingFulfillmentDataV2Res, error) {
	rsp, err := c.GenerateListingFulfillmentDataV2WithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGenerateListingFulfillmentDataV2Res(rsp)
}

// PostCriteriaOfferV2WithBodyWithResponse request with arbitrary body returning *PostCriteriaOfferV2Res
func (c *ClientWithResponses) PostCriteriaOfferV2WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostCriteriaOfferV2Res, error) {
	rsp, err := c.PostCriteriaOfferV2WithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostCriteriaOfferV2Res(rsp)
}

func (c *ClientWithResponses) PostCriteriaOfferV2WithResponse(ctx context.Context, body PostCriteriaOfferV2JSONRequestBody, reqEditors ...RequestEditorFn) (*PostCriteriaOfferV2Res, error) {
	rsp, err := c.PostCriteriaOfferV2(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostCriteriaOfferV2Res(rsp)
}

func (c *ClientWithResponses) PostCriteriaOfferV2WithFormdataBodyWithResponse(ctx context.Context, body PostCriteriaOfferV2FormdataRequestBody, reqEditors ...RequestEditorFn) (*PostCriteriaOfferV2Res, error) {
	rsp, err := c.PostCriteriaOfferV2WithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostCriteriaOfferV2Res(rsp)
}

// BuildOfferV2WithBodyWithResponse request with arbitrary body returning *BuildOfferV2Res
func (c *ClientWithResponses) BuildOfferV2WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BuildOfferV2Res, error) {
	rsp, err := c.BuildOfferV2WithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBuildOfferV2Res(rsp)
}

func (c *ClientWithResponses) BuildOfferV2WithResponse(ctx context.Context, body BuildOfferV2JSONRequestBody, reqEditors ...RequestEditorFn) (*BuildOfferV2Res, error) {
	rsp, err := c.BuildOfferV2(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBuildOfferV2Res(rsp)
}

func (c *ClientWithResponses) BuildOfferV2WithFormdataBodyWithResponse(ctx context.Context, body BuildOfferV2FormdataRequestBody, reqEditors ...RequestEditorFn) (*BuildOfferV2Res, error) {
	rsp, err := c.BuildOfferV2WithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBuildOfferV2Res(rsp)
}

// GetCollectionOffersV2WithResponse request returning *GetCollectionOffersV2Res
func (c *ClientWithResponses) GetCollectionOffersV2WithResponse(ctx context.Context, collectionSlug string, reqEditors ...RequestEditorFn) (*GetCollectionOffersV2Res, error) {
	rsp, err := c.GetCollectionOffersV2(ctx, collectionSlug, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCollectionOffersV2Res(rsp)
}

// GetAllOffersOnCollectionV2WithResponse request returning *GetAllOffersOnCollectionV2Res
func (c *ClientWithResponses) GetAllOffersOnCollectionV2WithResponse(ctx context.Context, collectionSlug string, params *GetAllOffersOnCollectionV2Params, reqEditors ...RequestEditorFn) (*GetAllOffersOnCollectionV2Res, error) {
	rsp, err := c.GetAllOffersOnCollectionV2(ctx, collectionSlug, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllOffersOnCollectionV2Res(rsp)
}

// GetTraitOffersV2WithResponse request returning *GetTraitOffersV2Res
func (c *ClientWithResponses) GetTraitOffersV2WithResponse(ctx context.Context, collectionSlug string, params *GetTraitOffersV2Params, reqEditors ...RequestEditorFn) (*GetTraitOffersV2Res, error) {
	rsp, err := c.GetTraitOffersV2(ctx, collectionSlug, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTraitOffersV2Res(rsp)
}

// GenerateOfferFulfillmentDataV2WithBodyWithResponse request with arbitrary body returning *GenerateOfferFulfillmentDataV2Res
func (c *ClientWithResponses) GenerateOfferFulfillmentDataV2WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GenerateOfferFulfillmentDataV2Res, error) {
	rsp, err := c.GenerateOfferFulfillmentDataV2WithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGenerateOfferFulfillmentDataV2Res(rsp)
}

func (c *ClientWithResponses) GenerateOfferFulfillmentDataV2WithResponse(ctx context.Context, body GenerateOfferFulfillmentDataV2JSONRequestBody, reqEditors ...RequestEditorFn) (*GenerateOfferFulfillmentDataV2Res, error) {
	rsp, err := c.GenerateOfferFulfillmentDataV2(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGenerateOfferFulfillmentDataV2Res(rsp)
}

func (c *ClientWithResponses) GenerateOfferFulfillmentDataV2WithFormdataBodyWithResponse(ctx context.Context, body GenerateOfferFulfillmentDataV2FormdataRequestBody, reqEditors ...RequestEditorFn) (*GenerateOfferFulfillmentDataV2Res, error) {
	rsp, err := c.GenerateOfferFulfillmentDataV2WithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGenerateOfferFulfillmentDataV2Res(rsp)
}

// GetOrderWithResponse request returning *GetOrderRes
func (c *ClientWithResponses) GetOrderWithResponse(ctx context.Context, chain GetOrderParamsChain, protocolAddress GetOrderParamsProtocolAddress, orderHash string, reqEditors ...RequestEditorFn) (*GetOrderRes, error) {
	rsp, err := c.GetOrder(ctx, chain, protocolAddress, orderHash, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOrderRes(rsp)
}

// GetListingsWithResponse request returning *GetListingsRes
func (c *ClientWithResponses) GetListingsWithResponse(ctx context.Context, chain GetListingsParamsChain, protocol GetListingsParamsProtocol, params *GetListingsParams, reqEditors ...RequestEditorFn) (*GetListingsRes, error) {
	rsp, err := c.GetListings(ctx, chain, protocol, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetListingsRes(rsp)
}

// PostListingWithBodyWithResponse request with arbitrary body returning *PostListingRes
func (c *ClientWithResponses) PostListingWithBodyWithResponse(ctx context.Context, chain PostListingParamsChain, protocol PostListingParamsProtocol, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostListingRes, error) {
	rsp, err := c.PostListingWithBody(ctx, chain, protocol, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostListingRes(rsp)
}

func (c *ClientWithResponses) PostListingWithResponse(ctx context.Context, chain PostListingParamsChain, protocol PostListingParamsProtocol, body PostListingJSONRequestBody, reqEditors ...RequestEditorFn) (*PostListingRes, error) {
	rsp, err := c.PostListing(ctx, chain, protocol, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostListingRes(rsp)
}

func (c *ClientWithResponses) PostListingWithFormdataBodyWithResponse(ctx context.Context, chain PostListingParamsChain, protocol PostListingParamsProtocol, body PostListingFormdataRequestBody, reqEditors ...RequestEditorFn) (*PostListingRes, error) {
	rsp, err := c.PostListingWithFormdataBody(ctx, chain, protocol, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostListingRes(rsp)
}

// GetOffersWithResponse request returning *GetOffersRes
func (c *ClientWithResponses) GetOffersWithResponse(ctx context.Context, chain GetOffersParamsChain, protocol GetOffersParamsProtocol, params *GetOffersParams, reqEditors ...RequestEditorFn) (*GetOffersRes, error) {
	rsp, err := c.GetOffers(ctx, chain, protocol, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOffersRes(rsp)
}

// PostOfferWithBodyWithResponse request with arbitrary body returning *PostOfferRes
func (c *ClientWithResponses) PostOfferWithBodyWithResponse(ctx context.Context, chain PostOfferParamsChain, protocol PostOfferParamsProtocol, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostOfferRes, error) {
	rsp, err := c.PostOfferWithBody(ctx, chain, protocol, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostOfferRes(rsp)
}

func (c *ClientWithResponses) PostOfferWithResponse(ctx context.Context, chain PostOfferParamsChain, protocol PostOfferParamsProtocol, body PostOfferJSONRequestBody, reqEditors ...RequestEditorFn) (*PostOfferRes, error) {
	rsp, err := c.PostOffer(ctx, chain, protocol, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostOfferRes(rsp)
}

func (c *ClientWithResponses) PostOfferWithFormdataBodyWithResponse(ctx context.Context, chain PostOfferParamsChain, protocol PostOfferParamsProtocol, body PostOfferFormdataRequestBody, reqEditors ...RequestEditorFn) (*PostOfferRes, error) {
	rsp, err := c.PostOfferWithFormdataBody(ctx, chain, protocol, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostOfferRes(rsp)
}

// GetTraitsWithResponse request returning *GetTraitsRes
func (c *ClientWithResponses) GetTraitsWithResponse(ctx context.Context, collectionSlug string, reqEditors ...RequestEditorFn) (*GetTraitsRes, error) {
	rsp, err := c.GetTraits(ctx, collectionSlug, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTraitsRes(rsp)
}

// ParseGetAccountRes parses an HTTP response from a GetAccountWithResponse call
func ParseGetAccountRes(rsp *http.Response) (*GetAccountRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAccountRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DetailedAccountDataModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListNftsByAccountRes parses an HTTP response from a ListNftsByAccountWithResponse call
func ParseListNftsByAccountRes(rsp *http.Response) (*ListNftsByAccountRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListNftsByAccountRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListNftsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetContractRes parses an HTTP response from a GetContractWithResponse call
func ParseGetContractRes(rsp *http.Response) (*GetContractRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetContractRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListNftsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListNftsByContractRes parses an HTTP response from a ListNftsByContractWithResponse call
func ParseListNftsByContractRes(rsp *http.Response) (*ListNftsByContractRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListNftsByContractRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListNftsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetNftRes parses an HTTP response from a GetNftWithResponse call
func ParseGetNftRes(rsp *http.Response) (*GetNftRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNftRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetNftResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRefreshNftRes parses an HTTP response from a RefreshNftWithResponse call
func ParseRefreshNftRes(rsp *http.Response) (*RefreshNftRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RefreshNftRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseListNftsByCollectionRes parses an HTTP response from a ListNftsByCollectionWithResponse call
func ParseListNftsByCollectionRes(rsp *http.Response) (*ListNftsByCollectionRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListNftsByCollectionRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListNftsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListCollectionsRes parses an HTTP response from a ListCollectionsWithResponse call
func ParseListCollectionsRes(rsp *http.Response) (*ListCollectionsRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListCollectionsRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListCollectionsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetCollectionRes parses an HTTP response from a GetCollectionWithResponse call
func ParseGetCollectionRes(rsp *http.Response) (*GetCollectionRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCollectionRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DetailedCollectionModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetCollectionStatsRes parses an HTTP response from a GetCollectionStatsWithResponse call
func ParseGetCollectionStatsRes(rsp *http.Response) (*GetCollectionStatsRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCollectionStatsRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetCollectionStatsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListEventsByAccountRes parses an HTTP response from a ListEventsByAccountWithResponse call
func ParseListEventsByAccountRes(rsp *http.Response) (*ListEventsByAccountRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListEventsByAccountRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListEventsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListEventsByNftRes parses an HTTP response from a ListEventsByNftWithResponse call
func ParseListEventsByNftRes(rsp *http.Response) (*ListEventsByNftRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListEventsByNftRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListEventsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListEventsByCollectionRes parses an HTTP response from a ListEventsByCollectionWithResponse call
func ParseListEventsByCollectionRes(rsp *http.Response) (*ListEventsByCollectionRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListEventsByCollectionRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListEventsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetAllListingsOnCollectionV2Res parses an HTTP response from a GetAllListingsOnCollectionV2WithResponse call
func ParseGetAllListingsOnCollectionV2Res(rsp *http.Response) (*GetAllListingsOnCollectionV2Res, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllListingsOnCollectionV2Res{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaginatedListingList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGenerateListingFulfillmentDataV2Res parses an HTTP response from a GenerateListingFulfillmentDataV2WithResponse call
func ParseGenerateListingFulfillmentDataV2Res(rsp *http.Response) (*GenerateListingFulfillmentDataV2Res, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GenerateListingFulfillmentDataV2Res{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FulfillmentOutput
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostCriteriaOfferV2Res parses an HTTP response from a PostCriteriaOfferV2WithResponse call
func ParsePostCriteriaOfferV2Res(rsp *http.Response) (*PostCriteriaOfferV2Res, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostCriteriaOfferV2Res{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Offer
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseBuildOfferV2Res parses an HTTP response from a BuildOfferV2WithResponse call
func ParseBuildOfferV2Res(rsp *http.Response) (*BuildOfferV2Res, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BuildOfferV2Res{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BuildOffer
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetCollectionOffersV2Res parses an HTTP response from a GetCollectionOffersV2WithResponse call
func ParseGetCollectionOffersV2Res(rsp *http.Response) (*GetCollectionOffersV2Res, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCollectionOffersV2Res{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OfferList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetAllOffersOnCollectionV2Res parses an HTTP response from a GetAllOffersOnCollectionV2WithResponse call
func ParseGetAllOffersOnCollectionV2Res(rsp *http.Response) (*GetAllOffersOnCollectionV2Res, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllOffersOnCollectionV2Res{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaginatedOfferList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetTraitOffersV2Res parses an HTTP response from a GetTraitOffersV2WithResponse call
func ParseGetTraitOffersV2Res(rsp *http.Response) (*GetTraitOffersV2Res, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTraitOffersV2Res{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OfferList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGenerateOfferFulfillmentDataV2Res parses an HTTP response from a GenerateOfferFulfillmentDataV2WithResponse call
func ParseGenerateOfferFulfillmentDataV2Res(rsp *http.Response) (*GenerateOfferFulfillmentDataV2Res, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GenerateOfferFulfillmentDataV2Res{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FulfillmentOutput
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetOrderRes parses an HTTP response from a GetOrderWithResponse call
func ParseGetOrderRes(rsp *http.Response) (*GetOrderRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOrderRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetOrderResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetListingsRes parses an HTTP response from a GetListingsWithResponse call
func ParseGetListingsRes(rsp *http.Response) (*GetListingsRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetListingsRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetListingsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostListingRes parses an HTTP response from a PostListingWithResponse call
func ParsePostListingRes(rsp *http.Response) (*PostListingRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostListingRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CreateListingResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetOffersRes parses an HTTP response from a GetOffersWithResponse call
func ParseGetOffersRes(rsp *http.Response) (*GetOffersRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOffersRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetOfferResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostOfferRes parses an HTTP response from a PostOfferWithResponse call
func ParsePostOfferRes(rsp *http.Response) (*PostOfferRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostOfferRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CreateOfferResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetTraitsRes parses an HTTP response from a GetTraitsWithResponse call
func ParseGetTraitsRes(rsp *http.Response) (*GetTraitsRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTraitsRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetTraitResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get Account
	// (GET /api/v2/accounts/{address})
	GetAccount(ctx echo.Context, address string) error
	// Get NFTs (by account)
	// (GET /api/v2/chain/{chain}/account/{address}/nfts)
	ListNftsByAccount(ctx echo.Context, chain ListNftsByAccountParamsChain, address string, params ListNftsByAccountParams) error
	// Get Contract
	// (GET /api/v2/chain/{chain}/contract/{address})
	GetContract(ctx echo.Context, chain GetContractParamsChain, address string) error
	// Get NFTs (by contract)
	// (GET /api/v2/chain/{chain}/contract/{address}/nfts)
	ListNftsByContract(ctx echo.Context, chain ListNftsByContractParamsChain, address string, params ListNftsByContractParams) error
	// Get an NFT
	// (GET /api/v2/chain/{chain}/contract/{address}/nfts/{identifier})
	GetNft(ctx echo.Context, chain GetNftParamsChain, address string, identifier string) error
	// Refresh NFT Metadata
	// (POST /api/v2/chain/{chain}/contract/{address}/nfts/{identifier}/refresh)
	RefreshNft(ctx echo.Context, chain RefreshNftParamsChain, address string, identifier string) error
	// Get NFTs (by collection)
	// (GET /api/v2/collection/{collection_slug}/nfts)
	ListNftsByCollection(ctx echo.Context, collectionSlug string, params ListNftsByCollectionParams) error
	// Get Collections
	// (GET /api/v2/collections)
	ListCollections(ctx echo.Context, params ListCollectionsParams) error
	// Get a Collection
	// (GET /api/v2/collections/{collection_slug})
	GetCollection(ctx echo.Context, collectionSlug string) error
	// Get Collection Stats
	// (GET /api/v2/collections/{collection_slug}/stats)
	GetCollectionStats(ctx echo.Context, collectionSlug string) error
	// Get Events (by account)
	// (GET /api/v2/events/accounts/{address})
	ListEventsByAccount(ctx echo.Context, address string, params ListEventsByAccountParams) error
	// Get Events (by NFT)
	// (GET /api/v2/events/chain/{chain}/contract/{address}/nfts/{identifier})
	ListEventsByNft(ctx echo.Context, chain ListEventsByNftParamsChain, address string, identifier string, params ListEventsByNftParams) error
	// Get Events (by collection)
	// (GET /api/v2/events/collection/{collection_slug})
	ListEventsByCollection(ctx echo.Context, collectionSlug string, params ListEventsByCollectionParams) error
	// Get All Listings (by collection)
	// (GET /api/v2/listings/collection/{collection_slug}/all)
	GetAllListingsOnCollectionV2(ctx echo.Context, collectionSlug string, params GetAllListingsOnCollectionV2Params) error
	// Fulfill a Listing
	// (POST /api/v2/listings/fulfillment_data)
	GenerateListingFulfillmentDataV2(ctx echo.Context) error
	// Create Criteria Offer
	// (POST /api/v2/offers)
	PostCriteriaOfferV2(ctx echo.Context) error
	// Build an Offer
	// (POST /api/v2/offers/build)
	BuildOfferV2(ctx echo.Context) error
	// Get Collection Offers
	// (GET /api/v2/offers/collection/{collection_slug})
	GetCollectionOffersV2(ctx echo.Context, collectionSlug string) error
	// Get All Offers (by collection)
	// (GET /api/v2/offers/collection/{collection_slug}/all)
	GetAllOffersOnCollectionV2(ctx echo.Context, collectionSlug string, params GetAllOffersOnCollectionV2Params) error
	// Get Trait Offers
	// (GET /api/v2/offers/collection/{collection_slug}/traits)
	GetTraitOffersV2(ctx echo.Context, collectionSlug string, params GetTraitOffersV2Params) error
	// Fullfill an Offer
	// (POST /api/v2/offers/fulfillment_data)
	GenerateOfferFulfillmentDataV2(ctx echo.Context) error
	// Get Order
	// (GET /api/v2/orders/chain/{chain}/protocol/{protocol_address}/{order_hash})
	GetOrder(ctx echo.Context, chain GetOrderParamsChain, protocolAddress GetOrderParamsProtocolAddress, orderHash string) error
	// Get Listings
	// (GET /api/v2/orders/{chain}/{protocol}/listings)
	GetListings(ctx echo.Context, chain GetListingsParamsChain, protocol GetListingsParamsProtocol, params GetListingsParams) error
	// Create Listing
	// (POST /api/v2/orders/{chain}/{protocol}/listings)
	PostListing(ctx echo.Context, chain PostListingParamsChain, protocol PostListingParamsProtocol) error
	// Get Individual Offers
	// (GET /api/v2/orders/{chain}/{protocol}/offers)
	GetOffers(ctx echo.Context, chain GetOffersParamsChain, protocol GetOffersParamsProtocol, params GetOffersParams) error
	// Create Individual Offer
	// (POST /api/v2/orders/{chain}/{protocol}/offers)
	PostOffer(ctx echo.Context, chain PostOfferParamsChain, protocol PostOfferParamsProtocol) error
	// Get Traits
	// (GET /api/v2/traits/{collection_slug})
	GetTraits(ctx echo.Context, collectionSlug string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// GetAccount converts echo context to params.
func (w *ServerInterfaceWrapper) GetAccount(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithOptions("simple", "address", ctx.Param("address"), &address, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set(OpenSeaAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAccount(ctx, address)
	return err
}

// ListNftsByAccount converts echo context to params.
func (w *ServerInterfaceWrapper) ListNftsByAccount(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "chain" -------------
	var chain ListNftsByAccountParamsChain

	err = runtime.BindStyledParameterWithOptions("simple", "chain", ctx.Param("chain"), &chain, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter chain: %s", err))
	}

	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithOptions("simple", "address", ctx.Param("address"), &address, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set(OpenSeaAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListNftsByAccountParams
	// ------------- Optional query parameter "collection" -------------

	err = runtime.BindQueryParameter("form", true, false, "collection", ctx.QueryParams(), &params.Collection)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter collection: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListNftsByAccount(ctx, chain, address, params)
	return err
}

// GetContract converts echo context to params.
func (w *ServerInterfaceWrapper) GetContract(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "chain" -------------
	var chain GetContractParamsChain

	err = runtime.BindStyledParameterWithOptions("simple", "chain", ctx.Param("chain"), &chain, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter chain: %s", err))
	}

	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithOptions("simple", "address", ctx.Param("address"), &address, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set(OpenSeaAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetContract(ctx, chain, address)
	return err
}

// ListNftsByContract converts echo context to params.
func (w *ServerInterfaceWrapper) ListNftsByContract(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "chain" -------------
	var chain ListNftsByContractParamsChain

	err = runtime.BindStyledParameterWithOptions("simple", "chain", ctx.Param("chain"), &chain, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter chain: %s", err))
	}

	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithOptions("simple", "address", ctx.Param("address"), &address, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set(OpenSeaAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListNftsByContractParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListNftsByContract(ctx, chain, address, params)
	return err
}

// GetNft converts echo context to params.
func (w *ServerInterfaceWrapper) GetNft(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "chain" -------------
	var chain GetNftParamsChain

	err = runtime.BindStyledParameterWithOptions("simple", "chain", ctx.Param("chain"), &chain, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter chain: %s", err))
	}

	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithOptions("simple", "address", ctx.Param("address"), &address, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "identifier" -------------
	var identifier string

	err = runtime.BindStyledParameterWithOptions("simple", "identifier", ctx.Param("identifier"), &identifier, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter identifier: %s", err))
	}

	ctx.Set(OpenSeaAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetNft(ctx, chain, address, identifier)
	return err
}

// RefreshNft converts echo context to params.
func (w *ServerInterfaceWrapper) RefreshNft(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "chain" -------------
	var chain RefreshNftParamsChain

	err = runtime.BindStyledParameterWithOptions("simple", "chain", ctx.Param("chain"), &chain, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter chain: %s", err))
	}

	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithOptions("simple", "address", ctx.Param("address"), &address, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "identifier" -------------
	var identifier string

	err = runtime.BindStyledParameterWithOptions("simple", "identifier", ctx.Param("identifier"), &identifier, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter identifier: %s", err))
	}

	ctx.Set(OpenSeaAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.RefreshNft(ctx, chain, address, identifier)
	return err
}

// ListNftsByCollection converts echo context to params.
func (w *ServerInterfaceWrapper) ListNftsByCollection(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "collection_slug" -------------
	var collectionSlug string

	err = runtime.BindStyledParameterWithOptions("simple", "collection_slug", ctx.Param("collection_slug"), &collectionSlug, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter collection_slug: %s", err))
	}

	ctx.Set(OpenSeaAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListNftsByCollectionParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListNftsByCollection(ctx, collectionSlug, params)
	return err
}

// ListCollections converts echo context to params.
func (w *ServerInterfaceWrapper) ListCollections(ctx echo.Context) error {
	var err error

	ctx.Set(OpenSeaAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListCollectionsParams
	// ------------- Optional query parameter "chain_identifier" -------------

	err = runtime.BindQueryParameter("form", true, false, "chain_identifier", ctx.QueryParams(), &params.ChainIdentifier)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter chain_identifier: %s", err))
	}

	// ------------- Optional query parameter "include_hidden" -------------

	err = runtime.BindQueryParameter("form", true, false, "include_hidden", ctx.QueryParams(), &params.IncludeHidden)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include_hidden: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListCollections(ctx, params)
	return err
}

// GetCollection converts echo context to params.
func (w *ServerInterfaceWrapper) GetCollection(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "collection_slug" -------------
	var collectionSlug string

	err = runtime.BindStyledParameterWithOptions("simple", "collection_slug", ctx.Param("collection_slug"), &collectionSlug, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter collection_slug: %s", err))
	}

	ctx.Set(OpenSeaAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetCollection(ctx, collectionSlug)
	return err
}

// GetCollectionStats converts echo context to params.
func (w *ServerInterfaceWrapper) GetCollectionStats(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "collection_slug" -------------
	var collectionSlug string

	err = runtime.BindStyledParameterWithOptions("simple", "collection_slug", ctx.Param("collection_slug"), &collectionSlug, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter collection_slug: %s", err))
	}

	ctx.Set(OpenSeaAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetCollectionStats(ctx, collectionSlug)
	return err
}

// ListEventsByAccount converts echo context to params.
func (w *ServerInterfaceWrapper) ListEventsByAccount(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithOptions("simple", "address", ctx.Param("address"), &address, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set(OpenSeaAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListEventsByAccountParams
	// ------------- Optional query parameter "after" -------------

	err = runtime.BindQueryParameter("form", true, false, "after", ctx.QueryParams(), &params.After)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after: %s", err))
	}

	// ------------- Optional query parameter "before" -------------

	err = runtime.BindQueryParameter("form", true, false, "before", ctx.QueryParams(), &params.Before)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before: %s", err))
	}

	// ------------- Optional query parameter "chain" -------------

	err = runtime.BindQueryParameter("form", true, false, "chain", ctx.QueryParams(), &params.Chain)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter chain: %s", err))
	}

	// ------------- Optional query parameter "event_type" -------------

	err = runtime.BindQueryParameter("form", true, false, "event_type", ctx.QueryParams(), &params.EventType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter event_type: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListEventsByAccount(ctx, address, params)
	return err
}

// ListEventsByNft converts echo context to params.
func (w *ServerInterfaceWrapper) ListEventsByNft(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "chain" -------------
	var chain ListEventsByNftParamsChain

	err = runtime.BindStyledParameterWithOptions("simple", "chain", ctx.Param("chain"), &chain, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter chain: %s", err))
	}

	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithOptions("simple", "address", ctx.Param("address"), &address, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "identifier" -------------
	var identifier string

	err = runtime.BindStyledParameterWithOptions("simple", "identifier", ctx.Param("identifier"), &identifier, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter identifier: %s", err))
	}

	ctx.Set(OpenSeaAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListEventsByNftParams
	// ------------- Optional query parameter "after" -------------

	err = runtime.BindQueryParameter("form", true, false, "after", ctx.QueryParams(), &params.After)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after: %s", err))
	}

	// ------------- Optional query parameter "before" -------------

	err = runtime.BindQueryParameter("form", true, false, "before", ctx.QueryParams(), &params.Before)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before: %s", err))
	}

	// ------------- Optional query parameter "event_type" -------------

	err = runtime.BindQueryParameter("form", true, false, "event_type", ctx.QueryParams(), &params.EventType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter event_type: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListEventsByNft(ctx, chain, address, identifier, params)
	return err
}

// ListEventsByCollection converts echo context to params.
func (w *ServerInterfaceWrapper) ListEventsByCollection(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "collection_slug" -------------
	var collectionSlug string

	err = runtime.BindStyledParameterWithOptions("simple", "collection_slug", ctx.Param("collection_slug"), &collectionSlug, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter collection_slug: %s", err))
	}

	ctx.Set(OpenSeaAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListEventsByCollectionParams
	// ------------- Optional query parameter "after" -------------

	err = runtime.BindQueryParameter("form", true, false, "after", ctx.QueryParams(), &params.After)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after: %s", err))
	}

	// ------------- Optional query parameter "before" -------------

	err = runtime.BindQueryParameter("form", true, false, "before", ctx.QueryParams(), &params.Before)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before: %s", err))
	}

	// ------------- Optional query parameter "event_type" -------------

	err = runtime.BindQueryParameter("form", true, false, "event_type", ctx.QueryParams(), &params.EventType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter event_type: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListEventsByCollection(ctx, collectionSlug, params)
	return err
}

// GetAllListingsOnCollectionV2 converts echo context to params.
func (w *ServerInterfaceWrapper) GetAllListingsOnCollectionV2(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "collection_slug" -------------
	var collectionSlug string

	err = runtime.BindStyledParameterWithOptions("simple", "collection_slug", ctx.Param("collection_slug"), &collectionSlug, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter collection_slug: %s", err))
	}

	ctx.Set(OpenSeaAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAllListingsOnCollectionV2Params
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAllListingsOnCollectionV2(ctx, collectionSlug, params)
	return err
}

// GenerateListingFulfillmentDataV2 converts echo context to params.
func (w *ServerInterfaceWrapper) GenerateListingFulfillmentDataV2(ctx echo.Context) error {
	var err error

	ctx.Set(OpenSeaAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GenerateListingFulfillmentDataV2(ctx)
	return err
}

// PostCriteriaOfferV2 converts echo context to params.
func (w *ServerInterfaceWrapper) PostCriteriaOfferV2(ctx echo.Context) error {
	var err error

	ctx.Set(OpenSeaAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostCriteriaOfferV2(ctx)
	return err
}

// BuildOfferV2 converts echo context to params.
func (w *ServerInterfaceWrapper) BuildOfferV2(ctx echo.Context) error {
	var err error

	ctx.Set(OpenSeaAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.BuildOfferV2(ctx)
	return err
}

// GetCollectionOffersV2 converts echo context to params.
func (w *ServerInterfaceWrapper) GetCollectionOffersV2(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "collection_slug" -------------
	var collectionSlug string

	err = runtime.BindStyledParameterWithOptions("simple", "collection_slug", ctx.Param("collection_slug"), &collectionSlug, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter collection_slug: %s", err))
	}

	ctx.Set(OpenSeaAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetCollectionOffersV2(ctx, collectionSlug)
	return err
}

// GetAllOffersOnCollectionV2 converts echo context to params.
func (w *ServerInterfaceWrapper) GetAllOffersOnCollectionV2(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "collection_slug" -------------
	var collectionSlug string

	err = runtime.BindStyledParameterWithOptions("simple", "collection_slug", ctx.Param("collection_slug"), &collectionSlug, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter collection_slug: %s", err))
	}

	ctx.Set(OpenSeaAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAllOffersOnCollectionV2Params
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAllOffersOnCollectionV2(ctx, collectionSlug, params)
	return err
}

// GetTraitOffersV2 converts echo context to params.
func (w *ServerInterfaceWrapper) GetTraitOffersV2(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "collection_slug" -------------
	var collectionSlug string

	err = runtime.BindStyledParameterWithOptions("simple", "collection_slug", ctx.Param("collection_slug"), &collectionSlug, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter collection_slug: %s", err))
	}

	ctx.Set(OpenSeaAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTraitOffersV2Params
	// ------------- Optional query parameter "float_value" -------------

	err = runtime.BindQueryParameter("form", true, false, "float_value", ctx.QueryParams(), &params.FloatValue)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter float_value: %s", err))
	}

	// ------------- Optional query parameter "int_value" -------------

	err = runtime.BindQueryParameter("form", true, false, "int_value", ctx.QueryParams(), &params.IntValue)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter int_value: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "value" -------------

	err = runtime.BindQueryParameter("form", true, false, "value", ctx.QueryParams(), &params.Value)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter value: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetTraitOffersV2(ctx, collectionSlug, params)
	return err
}

// GenerateOfferFulfillmentDataV2 converts echo context to params.
func (w *ServerInterfaceWrapper) GenerateOfferFulfillmentDataV2(ctx echo.Context) error {
	var err error

	ctx.Set(OpenSeaAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GenerateOfferFulfillmentDataV2(ctx)
	return err
}

// GetOrder converts echo context to params.
func (w *ServerInterfaceWrapper) GetOrder(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "chain" -------------
	var chain GetOrderParamsChain

	err = runtime.BindStyledParameterWithOptions("simple", "chain", ctx.Param("chain"), &chain, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter chain: %s", err))
	}

	// ------------- Path parameter "protocol_address" -------------
	var protocolAddress GetOrderParamsProtocolAddress

	err = runtime.BindStyledParameterWithOptions("simple", "protocol_address", ctx.Param("protocol_address"), &protocolAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter protocol_address: %s", err))
	}

	// ------------- Path parameter "order_hash" -------------
	var orderHash string

	err = runtime.BindStyledParameterWithOptions("simple", "order_hash", ctx.Param("order_hash"), &orderHash, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter order_hash: %s", err))
	}

	ctx.Set(OpenSeaAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetOrder(ctx, chain, protocolAddress, orderHash)
	return err
}

// GetListings converts echo context to params.
func (w *ServerInterfaceWrapper) GetListings(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "chain" -------------
	var chain GetListingsParamsChain

	err = runtime.BindStyledParameterWithOptions("simple", "chain", ctx.Param("chain"), &chain, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter chain: %s", err))
	}

	// ------------- Path parameter "protocol" -------------
	var protocol GetListingsParamsProtocol

	err = runtime.BindStyledParameterWithOptions("simple", "protocol", ctx.Param("protocol"), &protocol, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter protocol: %s", err))
	}

	ctx.Set(OpenSeaAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetListingsParams
	// ------------- Optional query parameter "asset_contract_address" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset_contract_address", ctx.QueryParams(), &params.AssetContractAddress)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset_contract_address: %s", err))
	}

	// ------------- Optional query parameter "bundled" -------------

	err = runtime.BindQueryParameter("form", true, false, "bundled", ctx.QueryParams(), &params.Bundled)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter bundled: %s", err))
	}

	// ------------- Optional query parameter "cursor" -------------

	err = runtime.BindQueryParameter("form", true, false, "cursor", ctx.QueryParams(), &params.Cursor)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter cursor: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "listed_after" -------------

	err = runtime.BindQueryParameter("form", true, false, "listed_after", ctx.QueryParams(), &params.ListedAfter)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter listed_after: %s", err))
	}

	// ------------- Optional query parameter "listed_before" -------------

	err = runtime.BindQueryParameter("form", true, false, "listed_before", ctx.QueryParams(), &params.ListedBefore)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter listed_before: %s", err))
	}

	// ------------- Optional query parameter "maker" -------------

	err = runtime.BindQueryParameter("form", true, false, "maker", ctx.QueryParams(), &params.Maker)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter maker: %s", err))
	}

	// ------------- Optional query parameter "order_by" -------------

	err = runtime.BindQueryParameter("form", true, false, "order_by", ctx.QueryParams(), &params.OrderBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter order_by: %s", err))
	}

	// ------------- Optional query parameter "order_direction" -------------

	err = runtime.BindQueryParameter("form", true, false, "order_direction", ctx.QueryParams(), &params.OrderDirection)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter order_direction: %s", err))
	}

	// ------------- Optional query parameter "payment_token_address" -------------

	err = runtime.BindQueryParameter("form", true, false, "payment_token_address", ctx.QueryParams(), &params.PaymentTokenAddress)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter payment_token_address: %s", err))
	}

	// ------------- Optional query parameter "taker" -------------

	err = runtime.BindQueryParameter("form", true, false, "taker", ctx.QueryParams(), &params.Taker)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter taker: %s", err))
	}

	// ------------- Optional query parameter "token_ids" -------------

	err = runtime.BindQueryParameter("form", true, false, "token_ids", ctx.QueryParams(), &params.TokenIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter token_ids: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetListings(ctx, chain, protocol, params)
	return err
}

// PostListing converts echo context to params.
func (w *ServerInterfaceWrapper) PostListing(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "chain" -------------
	var chain PostListingParamsChain

	err = runtime.BindStyledParameterWithOptions("simple", "chain", ctx.Param("chain"), &chain, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter chain: %s", err))
	}

	// ------------- Path parameter "protocol" -------------
	var protocol PostListingParamsProtocol

	err = runtime.BindStyledParameterWithOptions("simple", "protocol", ctx.Param("protocol"), &protocol, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter protocol: %s", err))
	}

	ctx.Set(OpenSeaAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostListing(ctx, chain, protocol)
	return err
}

// GetOffers converts echo context to params.
func (w *ServerInterfaceWrapper) GetOffers(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "chain" -------------
	var chain GetOffersParamsChain

	err = runtime.BindStyledParameterWithOptions("simple", "chain", ctx.Param("chain"), &chain, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter chain: %s", err))
	}

	// ------------- Path parameter "protocol" -------------
	var protocol GetOffersParamsProtocol

	err = runtime.BindStyledParameterWithOptions("simple", "protocol", ctx.Param("protocol"), &protocol, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter protocol: %s", err))
	}

	ctx.Set(OpenSeaAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetOffersParams
	// ------------- Optional query parameter "asset_contract_address" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset_contract_address", ctx.QueryParams(), &params.AssetContractAddress)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset_contract_address: %s", err))
	}

	// ------------- Optional query parameter "bundled" -------------

	err = runtime.BindQueryParameter("form", true, false, "bundled", ctx.QueryParams(), &params.Bundled)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter bundled: %s", err))
	}

	// ------------- Optional query parameter "cursor" -------------

	err = runtime.BindQueryParameter("form", true, false, "cursor", ctx.QueryParams(), &params.Cursor)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter cursor: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "listed_after" -------------

	err = runtime.BindQueryParameter("form", true, false, "listed_after", ctx.QueryParams(), &params.ListedAfter)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter listed_after: %s", err))
	}

	// ------------- Optional query parameter "listed_before" -------------

	err = runtime.BindQueryParameter("form", true, false, "listed_before", ctx.QueryParams(), &params.ListedBefore)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter listed_before: %s", err))
	}

	// ------------- Optional query parameter "maker" -------------

	err = runtime.BindQueryParameter("form", true, false, "maker", ctx.QueryParams(), &params.Maker)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter maker: %s", err))
	}

	// ------------- Optional query parameter "order_by" -------------

	err = runtime.BindQueryParameter("form", true, false, "order_by", ctx.QueryParams(), &params.OrderBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter order_by: %s", err))
	}

	// ------------- Optional query parameter "order_direction" -------------

	err = runtime.BindQueryParameter("form", true, false, "order_direction", ctx.QueryParams(), &params.OrderDirection)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter order_direction: %s", err))
	}

	// ------------- Optional query parameter "payment_token_address" -------------

	err = runtime.BindQueryParameter("form", true, false, "payment_token_address", ctx.QueryParams(), &params.PaymentTokenAddress)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter payment_token_address: %s", err))
	}

	// ------------- Optional query parameter "taker" -------------

	err = runtime.BindQueryParameter("form", true, false, "taker", ctx.QueryParams(), &params.Taker)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter taker: %s", err))
	}

	// ------------- Optional query parameter "token_ids" -------------

	err = runtime.BindQueryParameter("form", true, false, "token_ids", ctx.QueryParams(), &params.TokenIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter token_ids: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetOffers(ctx, chain, protocol, params)
	return err
}

// PostOffer converts echo context to params.
func (w *ServerInterfaceWrapper) PostOffer(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "chain" -------------
	var chain PostOfferParamsChain

	err = runtime.BindStyledParameterWithOptions("simple", "chain", ctx.Param("chain"), &chain, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter chain: %s", err))
	}

	// ------------- Path parameter "protocol" -------------
	var protocol PostOfferParamsProtocol

	err = runtime.BindStyledParameterWithOptions("simple", "protocol", ctx.Param("protocol"), &protocol, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter protocol: %s", err))
	}

	ctx.Set(OpenSeaAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostOffer(ctx, chain, protocol)
	return err
}

// GetTraits converts echo context to params.
func (w *ServerInterfaceWrapper) GetTraits(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "collection_slug" -------------
	var collectionSlug string

	err = runtime.BindStyledParameterWithOptions("simple", "collection_slug", ctx.Param("collection_slug"), &collectionSlug, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter collection_slug: %s", err))
	}

	ctx.Set(OpenSeaAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetTraits(ctx, collectionSlug)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/api/v2/accounts/:address", wrapper.GetAccount)
	router.GET(baseURL+"/api/v2/chain/:chain/account/:address/nfts", wrapper.ListNftsByAccount)
	router.GET(baseURL+"/api/v2/chain/:chain/contract/:address", wrapper.GetContract)
	router.GET(baseURL+"/api/v2/chain/:chain/contract/:address/nfts", wrapper.ListNftsByContract)
	router.GET(baseURL+"/api/v2/chain/:chain/contract/:address/nfts/:identifier", wrapper.GetNft)
	router.POST(baseURL+"/api/v2/chain/:chain/contract/:address/nfts/:identifier/refresh", wrapper.RefreshNft)
	router.GET(baseURL+"/api/v2/collection/:collection_slug/nfts", wrapper.ListNftsByCollection)
	router.GET(baseURL+"/api/v2/collections", wrapper.ListCollections)
	router.GET(baseURL+"/api/v2/collections/:collection_slug", wrapper.GetCollection)
	router.GET(baseURL+"/api/v2/collections/:collection_slug/stats", wrapper.GetCollectionStats)
	router.GET(baseURL+"/api/v2/events/accounts/:address", wrapper.ListEventsByAccount)
	router.GET(baseURL+"/api/v2/events/chain/:chain/contract/:address/nfts/:identifier", wrapper.ListEventsByNft)
	router.GET(baseURL+"/api/v2/events/collection/:collection_slug", wrapper.ListEventsByCollection)
	router.GET(baseURL+"/api/v2/listings/collection/:collection_slug/all", wrapper.GetAllListingsOnCollectionV2)
	router.POST(baseURL+"/api/v2/listings/fulfillment_data", wrapper.GenerateListingFulfillmentDataV2)
	router.POST(baseURL+"/api/v2/offers", wrapper.PostCriteriaOfferV2)
	router.POST(baseURL+"/api/v2/offers/build", wrapper.BuildOfferV2)
	router.GET(baseURL+"/api/v2/offers/collection/:collection_slug", wrapper.GetCollectionOffersV2)
	router.GET(baseURL+"/api/v2/offers/collection/:collection_slug/all", wrapper.GetAllOffersOnCollectionV2)
	router.GET(baseURL+"/api/v2/offers/collection/:collection_slug/traits", wrapper.GetTraitOffersV2)
	router.POST(baseURL+"/api/v2/offers/fulfillment_data", wrapper.GenerateOfferFulfillmentDataV2)
	router.GET(baseURL+"/api/v2/orders/chain/:chain/protocol/:protocol_address/:order_hash", wrapper.GetOrder)
	router.GET(baseURL+"/api/v2/orders/:chain/:protocol/listings", wrapper.GetListings)
	router.POST(baseURL+"/api/v2/orders/:chain/:protocol/listings", wrapper.PostListing)
	router.GET(baseURL+"/api/v2/orders/:chain/:protocol/offers", wrapper.GetOffers)
	router.POST(baseURL+"/api/v2/orders/:chain/:protocol/offers", wrapper.PostOffer)
	router.GET(baseURL+"/api/v2/traits/:collection_slug", wrapper.GetTraits)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+y9fXPbttIo/lUwen4zaX6jyLKTNKeZOXOv68Q9vk+b+MZuO/PUHgUiQQnHJKADgHbc",
	"jL/7HSxeCJIgRfklr+ofjUyCwGKx2F3sGz6OEl6sOCNMydHLjyOZLEmB4efPWNLkVyoVZYtjQROiH64E",
	"XxGhKIEmSSkEYUr/xHn+Nhu9/Ovj6P8TJBu9HP3XTtXzju12B/r5jackH92cj0eKqpyMXo5M9zc345Eg",
	"/ympIOno5V++96BhG6bxSF2v9Cs+/zdJ1OhmPPq5pHn6NsuIaENMWMJTks4UvyBsRlN4mBKZCLpSlLPR",
	"y9E7shJEarARRjmVCvEMQXtEU4muljRZogQzNCeolCRFiqOszDOa50gtCUoEVURQjLgGYYL+XBKGUgLj",
	"olJStoBmK8EvqX508uq/UVayRA8/Rim5JLmGWMIYjF8hSUgACdbDaGgkUkusUMLLPO2CxYAwqhD42swf",
	"ncJ8jlJZIVAqQdlCI3CFhaI4P8YCF0QRITdY4Nanep3rCLZtkCQwoROCV1wo9FakRKDgy4A+zBeroNcG",
	"rbRBDqmmIohecjliq9IQc5pSDSzOjwPqyXAuybi5BexqD0fRgfuijRn3CmVcGFrieU6AMpB+IjBVZk0D",
	"5FT9jUfwbrYSXJmvZoThea5RpKk8w2WuRi+VKElzZECCrGgGcYbergg7IfiRRJIuGEnR35wRTWGWdG3L",
	"ajSJMsELJEhC6KWmc8wQVaSwe4ZKlFIJ8JiGSuCUskVIn7AO6Nh3iV7bCfiFm3OeE8z8bM0ur8/mdEkQ",
	"TlNBpNuvslytckqk2T5LAnBJRFl8m7y1Pcc2h+CKJzyf2QHao7/+kCwxW+jVY0rgRDlYJui3Uiq9VzUi",
	"eYb+ejT9MK39h9Nk+ix5/uM8ezrFyU/p02SKcbb7LE0enYcbwgKB9i0QEUD/U2KmqLqurf3uOIIqVhZz",
	"veSZQYSENc5xQkKU/F/XnR+KMkUWRLT2IvfI85sjgrbo/jQ7MLJJDzBLSP76kjBlxEdbFi0xZRvsQt38",
	"KCVM0YzqSZzHMAOd6r1gqAi2JECiaZgDw+KCLijDiqQaTqIhnBnwB4PSmBv8Or1ekdesLCxgdvlGZvSQ",
	"oevGSLeGHaFBmi2xXLbJ0vBX/c6zFzMDM7crLKu5hVsB2vxLd9kisubCV6OP7XoEq9xawgHLXEcFyG/9",
	"718OD+cRuj/Aiiy4uD61i1DHwj5Dug8isH6gCdx1aXsYj8x2qIMedBkbskFMbdwbVgpsiAtFUkNZMhyf",
	"qCURpCxG41GBFU1G49FFjq8VG41Hc6n/lDzHTG8mLOZUCWjqfs4Yv4RXlzjHLFlqOPlK0YJK3WyOpX7y",
	"Nxe6kSQrnsO2FJRdkLne1EVZzDGFpnyO52ZQRaRiRO/IBScipwaIlFyGI/tXfuxZVv6bBgBUTTQc1V8a",
	"nJkbI8R3c3OORwdeEra3vszLRRvnvzP6n5Igs0qapVHT4TXCNbnqBd0EnS6pdKpdxkuWovk1uqSSKqe1",
	"1T/UT9zSXpG5pIogzFLEuP8gx1KhFVZL5LWXkKueaNDX7SuYX4ieChexPeTfHlj54zlmHUGvSEa1QF8S",
	"5Fo+kk6iaFHJUgQrMWoqPZ2iT/PM0uB9Vc5zmqB5zpMLw0apX9Cxk4jjQNMxEITI6RFun4zbOxFOPlCp",
	"2non9iC2+V3HOvQu2SEhHfItIxFudkxEQpjCC1AnNMAS5/psQRNijgdUohWmcDDQrwVJ6IrqU1UF6CEJ",
	"mJplfjBN1/Qelzk2/rvwWXOhK2QHWozVxOtAHRkEZIToSbvvIqp0bWjbe1u9bCx0BkiqwI8utF+93jXu",
	"UmCskGmj24kft8YBE/qBTBYTdHx4LMfoN6KXTi7pSo7RvlCPR20JFt1LNdbaGLoaSnOhCdp3Cz+cr476",
	"OVcIiNkngA5Q0PWP3n3dscduwiHNi2pALAS+1k1qUw3IazQat1il/6u9CMH8gnaxCaZUJlyks1LkawZ8",
	"/UERwXCOfn/3a4SEH0n0yvSFJBGXtfOge/G7yGMwUCYVXghczEqphyjIGlB+t83iYBy57hBOEl7WNnb1",
	"zvURBUjO3LGwTX9HLYrXEtoYhvJrpL/SJDgnaM7LxVLpY7LWUKyhpU2BR4C57jMllTMms6uNIUlyLKXm",
	"einCEj16wxU6wZlB2p9cXDzSqkQUnDd6uBgo1dqEcLzRS9FHg2868MxXhEmCK+KLKai/UnahERrt+a3p",
	"oYuy+BXrOozfTlhAh+gK5zmp6QVvYaD42Vyz23vZX1afqx+6de9d05c4IzmVaiYVVuVa1nVim2sRRKQ6",
	"MR9pxkVyYvbnPczi1HaGFoKXq2Ay/kXHbMDWNDP2gLoVqbkpKqOURFiQYE/MCRiBkoSs1DpJfArdvDXd",
	"9Bl91BVVioj74V6nprMI73Jv+jjXFb2g90Nr9IIGY/9JL2h8XZoW8hCTFkpuN0eTHMeVglHnuRXP61j1",
	"OusIxXRUCRqgAWlil0dMEXGJ8zjHoPYtIKzSx/VkLJnhPClzsLtUZ2jOyCzFeob61xUhF/ZnwZlaxuGt",
	"AxM73cebdqhx+JIIvCCzlXOZREyTpkmoq/MMvTk89QbJQMqkpXBnSRoA6Y5ItquGM6TS4mmA5WGaVB0f",
	"wNhy0nHWqyyH0Chmtw7glyuSGBEZmckJjNI2LtrxZynNsjgQq+oQZA2vlLUg01PGgviD0EqQS8pL2QkK",
	"eqUHjGD0kudl0bGy5t294OMPM0wnADMz1w1QYoHbBBMGCHRghuqGpXtx7KC6AdFigeL8NhDEF6PBDoPP",
	"Lx32QgCbqHOkXSOxcWMHr+cZQxneHRhGniNFi804xyZcIss5F30QWKGOcn5FpNpg6EPd86CBZ/K6mPMO",
	"cWDeOb13ha8LDQ2Wkii/yaAvA1ocAHRiRojw+AKLC6JmCV71z9+0Qwle9ergv5lmB3gVmzQrixmIadk/",
	"WMXDrP5sPhqE9zdlgd6aMTp56hpiW8/cB7HvPn7px1rPOAewxgY78DzA7fL6TqutQ40C6vshSqTdXKGH",
	"G7CMLpwjo46L/x+9x1lGc4oVeY+eIP/HGQtfzVZYKEZErYl72GgqzLmCpPXG/nGj+TzHyYXWF5sfBC/g",
	"k0siQGbpVu43vCh4SgRWHKDzf8ArqXCW6cfwAx6RYpXzawKzdb8DRc6Pr5etOdPaMz+h2tMAas32LZx6",
	"mR1gmi40NHpQN37UncSZpKn1F/kIgQYL13xo5vTi0DPsOTBwKmeL6nPbusiUyMn/8NTFbbxyTjua54Nj",
	"P1zMx9pjRcd0Athq5N/CT5z4g1aKFLHQnHS/gFNYa+YQQuPfW2XCRhto4hLKvHk/tkZmnNO/SYqwaQ9O",
	"HXdaQDllBAt9PMUaa9aNA1yI5Hiln0nKEhJ4SOck0UdInCh6SerhNKkZI8r5KuPGW3EQxIm0+eDrdwcv",
	"9nYRF/rX7u7z5z7gyPWAuBh7ho8lsErsY42emLlAsIWGY4wwKoi4yAkSnCvQuDjM1gitS5zT1AXgNIeq",
	"uK/uz3rFLnFeEk9vdMG4M66/Vkt9gmaphn1vWgEhx/A0wQzxlQmnAaMA+psIDp92gQ8RCDjP+RU0w+w6",
	"AC/Ef+XS4SIINogshSKFcwj3HYOOXLv1DpB6gAlgxkS+EOc5qijehcEQFlAVlYh8IEmpSDoZ6g4JiL0D",
	"KkPydp3t0jIEPJICrWPll9E7SeQSoshCine8pA7ciR6/h+RhwI4TvSLFI2lB8n61H66oMkd7Vua5Ryow",
	"NL32DCvAKES8PW5ys7WszK+7A61jV9YxOw6YUafTp8nQ4lzP+B7aEiMiIrpkQofL8bzPxxHAIAhWxMZM",
	"viNyxZmMhHLCsq+1WUIc2AktVjmBuJA/9uJBIIEkbUICJr4vAI50XzWDSlBcAQg4d8NjV3OcDfREV990",
	"OKEDB0PNE10LK9XMw5hXC5yCcXMSd7MFbrVNgLRfxEG8nTVfqy9JQKhN2r0Zb6Nzh0Tngo12+FqCYb1j",
	"IY3tHgDdlMRst30Gab/Y55Fg1ci+fEUUpjlJ940x/hVWuMtkEsafdNrdB5KqJ9C2o6lHTZ9jxoiY0UIf",
	"KNf7AE6DSCHrbHgkkekElSIPR/3ZPD3SXXe5Z+aU325EymtDUR7r/d+cMpLOUn3+aocNYWU0HNsrRA5m",
	"VEiIczVU7iKq9OGZiwJrCFNc86b9HxgDvbJPI668jObkjgiGr5v4PTZd9yNY8oTifFaQlOKZ7bBOcH+d",
	"j4cFKZxAV7/pnixpt4IUTBMEbdB+5YxqBCwM9HnFceE+DlHR692yDtD+sY6JkFqz9/Fvbjc5APSw4ZB/",
	"Vn7VlppThVF0cIIerrGNr9nG13wJ8TUkpYrHLLu/WhXBNHD6UZet0y9PW/47ZcEO1MZ7RkjP+PptzDFF",
	"WZKXqaa5RCvIXCCCBaNsYSJB3X6Gzsebko+PjLupxR3GoN8GKG0DlLYBStsApW2A0jZA6a4BSpU4tlLx",
	"vK1kDohcck3fZF3ZZ5jRAkyBA9DtWJg1ijySLocsR76b2inUPezaCl+cgnlrHttKBxn1KZrBwMakN8Ob",
	"GLlqZsB6mh2KaKgrQRJwIB1Skqe1BFzoCO0rDwq/i5gx8iSSImN7bozMo5KmpXuvUbffHJ4O17NpT6rb",
	"qadqO9lgda+oWlofliywUIEbAOeSI0EyImxgELaughlNH0c9PlHABloLerYgdGGdXgUGfxVm6F+np8eo",
	"FPkYnfzxC0qxwmOtyXHwfaVUkETLE31ABBOIblDzU/WZGobol+A/+syaZRuGB9ApqZzJUq5oQnkp+0FZ",
	"YonmhDAkiE2q1ONWXxt/LVXXnVCcVCPFYCmIwnolNyQonmVmU7vvkVRchIrab+5FB0WsV6zr27VTo+4I",
	"MnJHQRMgpImdoExzNe8ZBGcc9WMBrgsuIKmMoedT5ONmBh0EYaDWAbAZn+SPgAILm7g+jJW/g/aVmaht",
	"7TYtYF+GDonQ7WrG9BEYUmGWYhHZkq/fHSD3tu5o/YGI5MXe7hgRkezuPn/e8leiE9drl0bbs1pGAzVa",
	"ye0WzY4wcNFgvNainbo+WsbJVRrI4MYUsFQmxMI7Gwzb9VvkCktke4hv19/ty3213ukbyoi4S6K1yl49",
	"TWuiL5hUt1Ja51mVCuCX1O9ET9oRPdQrlzEFlMpVjiH/3Ggf7bx2SwuUpTTBkH685FeaJaXm2wl6wxmk",
	"RnrfutMAAcgwFd0G1I01M5RqVkUT+0e+BS7VEqZqzft6kNrsmpBHCB+y/I9NTGeHfp2ShBY4jzoEVSmY",
	"tCEELmLRtQ82ZymJRE8QGHT/MUYFwUwa/EAxk6qhDaGYX6NdV5ZDt1sQhagydnQtcowbsqWtv3KQxsIj",
	"6jU5autXxW0Y9yENQkWGleEYj7oiaEMc1SNpYbCxQcrr03+N0Z/w/99PXh2MEVFJGPrRGTxrtlJvUniz",
	"FIpnwiZmyMVm1Jnl0IiI/wQ4qYEyrujGI+e8UTujRneRrXdow2BEV+zfvUZyNEbrhkfDrAVeRwRFZBn2",
	"NaNuFVyCfT/MjUUENXF18GFNkDsibYgEJTCTeMMIidPgo7jbmgWKUFahQwuTJU/BWo0lOPCg0gbO85ZC",
	"XhuksSwh1GOHzvYa+RXoX6QOsvEFDGo1L2K7K17N5V9YLh0OTMhWFVwQTjReuOWrKWPUWJqu2jItfPev",
	"ydtSRRclIKZZajfXMKJt0kSbcPdd4SlmPOIQT1L5XCRdMKxKQeQYMULSerQIZnaR/VGTM0BCuNQBDMgA",
	"US3zZ13etcu6qhq2liC+ynYFI8v8C2FEVBFv63eii3MUG6+249LtxfYNPFJHER6vwc0NmLeitK7R7dSd",
	"0pKVeUUY7gQUAmTbt5bFwTYOcBQsxzpM9ywOmNFjS7NJ5b0wAnOj2LZmvHobg9bMYOKgrnkJfgOLBI1Z",
	"KoPga9Ns7I9drr2NJovEfIEhzJ7gKkqx4TSF3n38Sqt/VEKHvnYKOGLMcY9xhWSZJKQen1ubHfiCPyt1",
	"c1eF895o2xQIHErZpuhjtEDdOqqOk2iUplUjBag7utVlKHZoySa7OQPXe7IM0yE3dLdH8hNvQre3za2G",
	"ZjG9jSuTMbxpTGuQARVX3fBiIcgCKzdXfkki7qacZkTRgtROBBqklqoGT8cBXmsr2bkw8WW0jKxn/Rj5",
	"oDpz9iSv/Be6IVrZukyCyDI3J+y2ic5r68MMaS7aub1oLot2EHw+5XY9jA2UAwo83MGw53GkvslUDz4z",
	"tW7GLfNIC6BMNVY9HDIO1Jog9O0yb7zMAPE76L0nqB+z6wH8xOsj4zVYMtz9vHkQ7U4FqGgkhDc+IzB0",
	"dtOIdVZXVoCI3rKu7mdQVfImcD9+vBl3mIBNLEM1tLXc/IyTi4XgJUvHkQoS+jysloQKmxoGn/hql62p",
	"V6GuXZPqeh5JB2p2XouejccvuWBM/a1WtE5O3x29+cWoVylNrP6jTy2YMiMoDVpMipqeLVUSwTQm6K1a",
	"EnFFJenqQD8tqMFSgT/YXiQxeVOd4SAHBkutKd7UqKxOQxF8HAV5aXV0TNET9MYkPz2xOXY/eI9jmBXl",
	"N/uCXhJmihg+PmO7+rN3B3vTM7Znfr7Y2z1jT83v3d3nz8/YM/8CNFKv0Z6x51Wz+qvKSjwd7473xk/H",
	"z8bPg611FCRctchBk3ElknvkbIXy28SqRmJU21ELnqHGmf3BekYfOuAMtxwaDKM/hWHP64ewGG4iRKOb",
	"gu2yB4MmhxfKEddROIwFt4r1ruXFmp9u0P4E52SD5mCvyzYa4R1JSQHLGX50ftOw/8rPSRK1VYrTRGOh",
	"O8jhTaY2VlvvYz5jrX4N36OVEhd0bNywtSVoq3hd6KlNvAM51r7ywPXCoYWp+WvtL1QizibD63IPrLqt",
	"lTFbqKUP4vZdGXcz+25Yft6PtJkhteVliB4jrfXTGUUbxn0PnrOCqgGZ3wkXZAaV2+VsBmMbvWx9jXPb",
	"v1uW5tT7a9//6m1sLdLtjjbcBvx9QQF/20i7oYFRJhsvcM353P86TrbRckOj5b76CLXPFWv1vQYrBZKn",
	"L96o4/YsrzNtpCmNH/CSpM4LkmTXDUn3rYl9f/rUEI1oExWo82YucyXQtljUtljUl18saluY6VMXZmpy",
	"kK4iTPBSH7MifgkjKQZ7ZYy/oTGuXGe9sKM04UUAUwzghiktbtsbbssLjC4fm6PFnbRQrNAkR5oaiprZ",
	"zKnmfxP0ulipaxuGvkYG17LYAOhPeHWPvdwMS2QPiy1NZJgltFIe1mPvsI4O8LwE+BibmA6Lu5YbwgeU",
	"tAPAouWCQr3mNhfPNQit7965Zhhy/do58mFFTchJR80YvUTHXNIPIDqlwsUKaXbXXCzASM4lsYWZGEdV",
	"31ovAY+QJMpisi5opjVpW31XrzETMMUCX8QO1r/px7Xgylpp34v4iXjDu/cYudJnQmtKaI7Sr3WaoYZY",
	"tQJD1nhkyyYPJ5B2gHTt1l7b3d3U4PplhHe647J2FPWpAMDNbhlPr0XPHUk64D8Nad1NlypOl6cturT6",
	"FmwAzozC5EpirwS91BvGWqNrzPg0TsR9mn1AcxE1vzrTBDhrM4axlV3jMGa/cMDYfx2ZBty66eLvv0Wy",
	"l68F9f6aJQIruoIeOuJFV7e4Frnq76C6brsVuIDCl+ORDwluU8KJe+WvfTM39ILPHEwUPkHFmChM1XQH",
	"uMkVqqmPfqy1sbrhBc0ViM25dIbLRVERsXCztKTqv0lkax+ZFCci0ZUpsQdNx4hmWvkfO515TlCpqD3b",
	"SYSR5KVIbJ0Fk+izWgl+iXNpKrOuiMi4KGxKFLgb5QT9fI2sGEQ/0AmZmLYVfFYgOdMaHFf0lnk8roS2",
	"E20LgZnynQfjK+6zMlyE9wSdsVPuphBcxuznW0qCXGT2i/l0b+/pdPrTLn5B0umu/v1iL3sxnf6Ip9Nn",
	"6Y9T/I/0GXmxmz7/6af5P3anz/aeTzP9Zd3grnu+IB1lrBrxth3pJeZmZcMHCxtJbgvjAini6hLAloZj",
	"eNpbFhSQaVbRlb7TsMqYqd4OlxajjJDJ8JDJZhnXm65g2rabGEJMogqEhrDAypXutPX8bftGwIalkAk6",
	"yqrQYSaDzd34fowgBghKXP4lCHa3aQdelPMflkqt5MudHbhVViaYTSjfsVx6Z3g8/3/p/p0j5r8O9x5r",
	"HbvqsxkQE9eMCEtPadcVAOAW6pehIEWIbNhSXIBoS3r6oONeAoXztk3wdztSkACXdl0eSReZPZioquPo",
	"TaeVyxPRZ7nEnHu1cBP9UeI8YtzADJmrgLG4djyWZ4gwJfjqulO9O8F5d4XrO5HLnCS8IDb9nzS1rk6y",
	"gVjit7YMRIsvyJgQ/ruDT8HiTprRy67ERK2tIagYPH9zRmJ1sIxxDEmiBYHGuUscwErhZEnS1tXemleY",
	"C7PNYznROjV1VrZxVZj8vV/v91quvSN6XRJFUiPM/oaMIFETbFhY46dWP/UpXYvwYGBb4jzg72dMH5P5",
	"ilh7szSizEtPl1Rg2gkPQ6u1VXoAKrdTzsrp9GlycvTLm9evZv/z9s3r2f6rV+9en5zAi5Aa/kfjN0KA",
	"urt/RU9x+/a8WTPV2U3pLzMCaAChQb5IaxKVawnaa0Q5SQ/fFvgCSlOhVKtaBWXYueivlsB+wegJudf6",
	"m0B4/sYhVFQRFjsi11QU1JQDm//XwOdy0DXxni+5RIykIWgrHlAJj5Bp2c0RrJVlTuNQcawEdFQ5DdTP",
	"XjX1T6qWx0Ea3Wc6DXwlCZtf2bFljWcqTgRd5BIP5N1nSB84LXWHZRaq/DpchnU/Z9W+cKZE/ygogNaC",
	"1Mlp/0fnZUNzLGnyHj1B8AMu5ElLlSz1I/hh7uhhi5xKeGh/wmN3KtfP22HBI+hyNB5BP/AcPm0e56NH",
	"7j/2Isq0PsNLZN+7+iea/0nn2wRmiB5JWtAci0fIbDT9FE6IVwQt8SUx4Samn13ZutTeSMjuKoKlDSE3",
	"khWMFlBhxXwXEbumwoTV1RlHOWcL68Gp3DetkI4k55Kyxbri24F1KecSjEu1SttP6npOO3JqeP/eejV0",
	"ALPKs5XgPItJ0XtwNjptsrtMLivzHM/15oClG+mDzFuWX7u/W4c5c8jqugTvwJ7B/M13NZ22deKp7F4q",
	"rsp6BbZeSUT3XKOATsADTTHTWiX9eyDlaprFue712pTP6qNGy6JuM4uQzobMwhvjBwY2wO0frlZ670UV",
	"68q52tW0dffM5qWyudknrVk4oGcmjHtesjQnPQkyN+tiDCfdiKpEjRnS1XgeVroDcHVI7LVG/RsBTCnp",
	"jDLYioNIqhbmZj/07nzGVZ3ndQAQUF2fK2U/Gj7auRPrrpIN9LOaI6y17htoY81L3ybo9HpFE4hvUMEZ",
	"31KhswM6JW4yGszLHiRYqDV1QXJ8Hb2gLhIyuxZSQQpMmWYx3b6cUwjTse2Qa9eofqIFvWZthtwqtmY8",
	"JKbsVVaa+6RtyKA7Dcd9PzTtMEHoN7XBx4hQOJPNaYp+AN3ssT4mY3nxg2Wgj6NZoerLZXmqk+WpT8/y",
	"1IOyvGaaltcDG8pYQ3dqaTpNHaKtBoSiuiFbKzdYRKTUmH6LQ497HHURB10zNM/v5+hmtBuh8s6pGHjB",
	"AsXyg4Pyj/13+dwlgyAsxj7sDp9+jlMVk7MV2fQAKRrmO+6o9BWMed6og9npzTzGC8o02dlUkXgok/Py",
	"9lXOty0GWrGrLOxmsspnTZnLKxia+WAeU26unSFWvmVPcNhDJs190sCzPkT1R6IdY6Eozo9rNq41VXga",
	"xNfvyoNoQuNQ1azVXD4SVtW5TXm6O/n0tlb321jdnTmRvCCJ/v/86XT64sWzuX62+3T32fwfP+5Op3t7",
	"839sDfCf3wDfNLc3jek1TtHkADE2waVysYjG93mbcl4PliPSKIdRj1HtCKf8aqzttzzpBTE68XOE3eUh",
	"Q6s23LygSpkdZ4+rDZs8SetVRjsr/jklNLAj9xnkOygtRpNaBe9KnwU1Pbmuld90z6J3KVTFhweV+YUt",
	"H7b+Ax6s3ZcVDEHdWtNZiIRqapGJv8NMc65DYqpJtmdvdOoZVkrQeanILKmSFmy473TIqc3nuhkdfd/1",
	"hw46khBuwmLrdSCj86jXdI8U4HFZOj6Lr+d+ue5k3irZZz+qqxX4w0xgdjHI3lFFCX9AepJR8oj3ZkvU",
	"66+CHMreIjS9I+hjXBZQwdBS+vWVaXOHnlnbj1H19XgkEx5zBfb0cpLw0KFnS41DaIjAiiyc8WmTuwFO",
	"7KdH6ZAZhWNdEiE7Uru7Z2A/Rn/Yj6OZrwrnM1BerjfbfM24EnRiOll7CgW6O29eedB7u2YLe11ki/MF",
	"F1QtC9DpJ+jA2YPHCOdX+FqiR1r3NOXvHwXuwuppG7Rw1cajaEGXz5ocI0hKSFFPxPrkeS4aCIcYxBMQ",
	"IultU0JiOO7LCxG+fWdySCZ40a1G7det35KwepjYoeDFPWUAuNUaGv2v+GCwfURrbW/2wd0ojd5Y6epl",
	"PWkkiu7TWr3yNSqGDdyvLUptqtEQ/RDacJfGdmSMi6ylqiAqP5hjLE4gfi1hO9QEnkdu9L0kgmZwRQZn",
	"rqRu/fILrmb2OTFG0eq3idiGn6Yf+Ony7GeKr2ZKEJZqWM/DWMeOqxQbVbAevkjR2lw5n1y6PhZhbQZM",
	"QDX2qek6GNLzq0AhM4N2Z8fchq/VEd3H0STOSScv+5wJY7WjWG2lBhcr+CLzvyxluNl8ilywIN57sDAY",
	"mpK1PsvqtszfEEBQIP+WMqC/YEMlBxrOr0EZWx2CosHnIiKib4MGwgF2Z1Qs9Jh/v9XqEbEyUdviEZ+j",
	"eESwEreoHVFpjwOSQAAxNp+qw69SeRZ8eI71B9ROKu9CpTWahvGl1bNo1I36pspZhGQQcs4evhZjo1UE",
	"zzdfPGfL/r4N9rdlNZ+vck6MX/SzFVfK/+5pMI1O+3Jh1uSVnNYjdR/J6jotg3bFzU6sRbffOZEkjsd6",
	"JGonDrfZ71939vunDEoJEs0rq3brjNpKgjhvZ2ffXzZ2XzJ2I9DpFuj6hlKoTWHpKnZxNiOXxWyG53Q2",
	"KyC3aTaThvxrhae/yXzrhv9rm269TbfeRnt9w+nW3UpPTEMCAjOR+53poC6c2Zi635qPt7mc21zObS7n",
	"NpfzHnI5t4mV28TKbWLlNrHycyVWfldZjl9OQmNn7mKdNm6VvjiQZoIyc2t3d8JZRhcb3Xqe0UUv281o",
	"Tma0WFR3ydQ1PSiuuOQ5yKUCL8gEHVohgRNV4hzZTszbMUqcjeUXopBFICIsXXE6cJalNLt4IJten31p",
	"0daerx2rmwD0HmsvfkUVt2U0rZWYY0nlDHAUU4abU7NdNb6LzoMnFOe/kZRiC0BH0Nkqx0ofDzqYNHSD",
	"Ct0Pck3tpbLqiioFLjREmVR4IXARRvG4jjuWOn6pEGwk+9arJVEowqQE191ac371rQchPL92IC2CX7jr",
	"tY1NpyF521TtctQKAbfMGbFssZUkYqDpArNj5VMqV5p3Dqks/sq01dPxQfMF/jDz82icuQgF0wxUpuZS",
	"0nkOKdZE0CS8v1c2kig6sDCu7pQeHCzf8MyEwV1QVCuJeyBbuS/od2l4WnDV3v7xEZA8wTXXIiC7MyHG",
	"DayidcMgBz24UKt29/M1+gF23KPq6udHj0GSfviVsIVajl7uPp82AVlLey3vgk++iPobakaESMcxj0R7",
	"ksZkVpulndw7YmZV3xKtLXwxqmEypMOundG3i8PQvI5w3FZ8IZCxuQH0KOpAPwiviqyf+EvWEQnoTixO",
	"walczAVRSw42UDDOxqoohzH0boSYw56tSuVPM03KT3hKUnSgBfmrxqVQkHlnboSKVezg7e6OW9NwJzQ7",
	"j2zdRE55L/U2QlkIbZGWW9pJi6jWKhFZhUR/7Sf39FVD5PmauMwGtWX9t718qhhw75i9aw5Je1J98dZu",
	"2C8/f+Q2UcNfXgpJBN+3SSBRtW/60kliFU8idD9od3TGBftZnUcPS7fywEYlMpQq5ZmzT5jt47xGRKIl",
	"vwrKs/uwyzM2Rf9Eh2WeQywDeoLecLQyyfVgUIEYrmvnnLLfnbFd9E9kc/Ddh8fhV+AP4wJchrHv99yo",
	"lW8xOja4E52PkYvKTZYsSXKBaBaZ1Bl7GkBXG6ATxtuN8wz9s7L2Pal+WosKxOGZm6jcCzOC9fvp/tJr",
	"hgtrHFwQRgRWxLtnj5gSPC0TkiLKvKHwcnfyzBhbvQm2ZH4uVcbQdLw73hs/HT+L1mONsYWOu6ZbBAel",
	"VNETZHkMxC0IgjL6gRg11ASUwd/Wm+HK4wDgtoTKGYNarOgJ0hTszXzezm/MU+AF1Co6dDQ5Y7Zw65rP",
	"CspoURb+K1+/xXwWFNvXoOMkIStf3JdKA6L3l2ZakUXN67Cg7G8tR2tgjdl2cdyb8UiSpITkUi2ujIi1",
	"PsX9UoFdXIvb0ZJgI0nMqXT04Qle0Se16CC8ov9Nrkc3N6BHZdyGbil7ITYpMM1HL92j/81XhEmCJ5RX",
	"vVZXx4LVZeSubbi6upoE7W9iMlyfOfTyt6+fdT7S/eMjk6lmMphHe5PpZAqHpxVheEVHL0dPJ9PJU0jh",
	"UEvAxQ5e0Z3LvR1rWZA7Hy0rv9FvFyRyQtJnIewvD/emnmNnDmJJXqaaslKiMAWGkCwRlmhO+bh+lHdn",
	"cBvSWrMoaQLQipEJEknNwPveABKGIP51X9eRax5lbLlQiEh3pTFVLWAl5yopaYxSRh2KmXDA7CNXnElD",
	"fnvTqSMdl561WuU2R3Hn39LI96q/3mM5oJikFi9VcjdQaR0pmhKembEbOd1ElYJpbmh0E7eiKSfGD0A+",
	"UAm4CfxQKywkSSe60+exTo+Y0mubI0nEJRGICMHFBB3nBKKstXDDTlQgRZMLopDknqr0SJRdEqnoAisy",
	"qe1lWPHaLv7rXKNZlkWBxbWl0YpWFF5oKhm9OTxFr61FUo7OdZeO/oE0dj7CPzduN1SbYYdlxj7XuSPe",
	"HJ66mnFw64257cVHD1mfVYumf6VSvcmU/Pn6ayTtcWcMWfPEwbVyoIjLa4bKaR2AOJ2zGwwnF0xgXFmM",
	"xv7nbMGJyGn4hPFLzS3xJc4xS5Yk/D3Lyn9TMKfyOZ4buyqx/1RdzWVi/q+IVAyypSFMiMDQvtlFjq8V",
	"A4OEAnlVlMUcU1hzRQsqi+Bn1bskK56bCG6eY2Z/pOQSQnAEtv/M3ODn4/XrYKu0mAYa+5YyNGWGxZE8",
	"G7f+PauLGcE8v0aXVFLQEppVlVjtPqYrMpdUEWDijPsPciwV0otbVfX3a/6fkojrYNHDgicbElxVuhE2",
	"oeJIAEerSjPNiboihKFdgPD5dIJemRPpS/R82gFRTgswqbaACUwGMWiS9SUDK2eqcKwXUm4wWglySXkp",
	"Xap6F7qYqTT4eYSO41nv7AAbCZtDbmUBEgRLzuQY6TmTK8cZoEt7KfmXK1yA0n6Y+/jQx7cRM443D1W6",
	"kCxwENJgknispDEMV5N3p6z5hSh3ltpKma2U2VjKbHnKw/KUYHPeAytZr7IWZa7oKieGmRlmUucwffrq",
	"lpVsWcn9KaxbPW6rx31WPc6xncf3yH13Plb8rV+1K4jCGlVj4xGXY1PfXi7pClFmHO+UM2MmM/XzHMOm",
	"bGFYeFThe5NtGfSWQd8Tg9b7wSV2dKC6opcvxkZqdsH3zOQw00v3UIxtR5BMEJNjsOJSxQzM0MBzuQGs",
	"y36yZV9b9vX1sq9G2UBH/UssTWqFLJOEyKzM82v0n5KU1sFr99PkW2ZLjiXoNXGIGcigvKV452NwY6rM",
	"y8Utz7xVL/3n3cBC3cuRvnzje4O/1LF4d4a3PchtD3Kf8SDnqPnxpgxFrjG/5+AGzyqwqy/jnOMg6HqA",
	"GjNYUehyokG4W02GbbBzfUKqrTmoNwJa0jSFEkDVTKutCje7dMBiwkDIzHQQg8Qnqq5jIsHg63nJ7jRk",
	"JrvTLTe5DTcJCPf7tsiH+3czXtLWTtY598xxKBD03aFUGSGyshVpus8pu+jy+W0Vl88TlVVhfvOgrG/F",
	"9IBq5HfXLbQjFV6j4UOLuoWhT8GvbZAT6H27Sz6VXa6B+a2oAQJwVOg2yz7D+bWiiezaMpC2IzeO4fX6",
	"rPne1oT1iekQ0A1NXLz2yl8kiiFuGzQ8VK70JtidTl0/KyJAJYrrxJDU8a3EOx5a1ZybVAeHEosIiIN3",
	"+VUIA0w4c7q8idvxtfYMvn9n9AMiK641f1qYCj2FVXQps3XpuvR/6DumN7q8zrtNYE4ybuvR3QH2Lp3X",
	"9L4Z9LezrsZOTaOtOXVTc6rLjQJaCVA+v56gowzixFeCX9LUZwJJnBMZlG42h6OudQmSEcPF8ZVS/Crl",
	"+WhsK5y4+iGwq4PLk9w1L315Y80CKt/v6c+w6O9ZGhsMdAV4DhXI9xwkEBfYoRvtgUX2V++N24rrr1Bc",
	"b52hW+l9P9L74RzAW2VhqyxoZeHN4emtFIUen/ZtVILA4PXAKsFw4/JW9n5W2fvdByVsj6tbCfQdSKB4",
	"+MNaQeQKifSHV2na7RVHeW7vBRnbcvC+QMkmDpn9PP/VfveWVRLmj72ta2Zw5JVH/DZi4sGZ0LHTqCzV",
	"6n82YkOndTLzd5A3SnBMzpipzUPEdUVb8isry5HnyO3uHo4VVjRbx7OCS5J9bcOuSHQlKLkk1YVQYXJN",
	"FW/hL5STY8QISc0NNK5aIXa7y19ghjgDw0SMnZnqU3bKhxWor7DCwNLscv/M0+t7dK52DQuVHGHdwt4/",
	"PLm6unqicfGkFDlhUAryfoczobdYqB0Yxi3UfQ1w02SeNw+444Px35bKA7DBdreLrnmeLYRuNndVC72x",
	"+c1ra0g1zzFDr//4zRQiNa+b9dJ9y6oqW+tmBHtjFFTeb+hCkpCvRxE69LvTEslm3MRUT+tmHQdQJz+4",
	"HNYWM1McrUqRLPUUMQMTgD7C1RUOf7EQVsmS2ApsK5LQDC63EphGcq2PuVTufk+4mu7BuEVrpAdhEj2j",
	"3Ik3dPb7SVmCua7wOzt82E3hsI/8nY2b7rudeUnztHv3/axfa32QC3dNUWsnVuIbKhWaq6qUICQQ4bp3",
	"zTf93Y/1LQfDPOxeq4Z4kE0W6/5Ou6vd4SfdVtXw39vesiTP7rCpbm1Xttd8BAf5UJrZW+Ld5Qxejg2O",
	"s4QZye15/lMdUAHf/afSZz11If0NpgHqGifTryOy0tDdvW+lW9jFhuwhaxQxfgb9I6WXNC1xbsoU14Sf",
	"7DKkmSlvzWi3NKPZddoa0T6dEW0As7oHgf8tc7z9PLes7m4GtiGsz+QgbahMmGtfbqtHwJUuWxViIC/r",
	"vG/n/XTy/P3jimuAz7N0VeZTktAC50/mWD+pXd0E7JAwWQqCKFiwjNUZJVwYc2gXg8lyjpW/q6eaiL9Z",
	"CBpUJdf7Q8m6Z7Y77Z7YPU2FsthEhjHz9j1P8eudYuO2HMx3IwJ/6VJsrM75fSlK61YO9MoBcw3YHZTe",
	"T+5YsYfLDfwqMLtP7VVpDvqgPpXuwe7Fo9LV/dafsvWn+F15GxMU3LbTyIFw+Nz52MTszc7HaqkGpsrb",
	"W5kMy+DCeWXHWl/Tst3fmr+cIH8dndbMzNV9WBiy0SQOtmFhYsOAWDTDpzJe2uMXotztkvdX02Mb7/6g",
	"8e6wqPWrzuFMD1KrA/e1e6nvGgzevAXRwuJve7S3ItrbkJon9TpgkWux19LHX6Pph2ntP5wm02fJ8x/n",
	"2dMpTn5KnyZTjLPdZ2kyOv/E5b/djnoHe+F7DOHz19VuzGEdb/Us9cZHxqw9luulyIkiSBKIIo8H70U5",
	"oIvhGRj3bbmcuQkssh300ezN4ekP8vEEoTOG3rw9ff0SHWVwcBubtI0ZTTVT938YW5eh+65zGtzmOHPD",
	"BRtmg/3rLruTfhbNIHCzFNXFZ/OSpTmRrgTawJpJ5qv0FsWStlLmy5Ayn8RMawa5yz05jlw3Ksy3d582",
	"7Y5kinAfXRFhMldI2p8KYrCJG0kV5v2AbAozxKydEVK77/qJ7nI0vnWOadfM+jNF7mdqkXyRO82twcuN",
	"OlXgCyIeSZvFG95CE4MMWm9OwmYoGrA4CRI5YHAVwSYQnJLO9BRrIuU9UcsZ3GD5XqPXSJj3cUnxHjbC",
	"eydy3tdODV2zM4rj/DpaVSIEy3A1A8tgJmOMI6ZA2CBE6C56IfU9xstgwNfQyRAQj/F1ATc6Q6blfnXp",
	"d1ajHkvexvgqwW7kGaLdLLjaJhBR57IH4ILWpNM0uzIAzMya3UriQ8IQwC+JUjmBCd1JVR8kXO21xIPQ",
	"3LcX1UZ7UW2+F/f16VngazjFAJ6OXsEaS4JFYq6fNgbm/+U1t3/unpXT6d6P1YO96U+PPRkYFbdWfLLK",
	"brQEcUXVstL+IJiSsgWEXdrjlAYD1kWzTQ3hJKJMxnf6EG3Sw94v7h74qORU73UpT1/oUSc4Oaw77Yw7",
	"zM26i1rpC/TD63cHL/Z29fHg9buD3d3nzx8DFUqck6aTrsDigqhVjhMSj7qtAoi39p2vpZ7BF8Wtzx/G",
	"/wBGAjDQ/0nV0pk079vx0DPKnTwOnf1+UleDCVm2O/x7TRq1cdu3S5ToNDtVKRQbxIIEYW02ks1oBN5b",
	"405QQwLevK9za5LamqS2gnFrktqapLYmqa1JamuS2pqktiaprUnqAb33WvH+Su1RR9UJZHCs5HhNljiL",
	"ZYevsVfFbVEu9GpridpaoraWqG/PEjWIc37jdqgmB97MIGUyOW6R4WxTQBrVOrpzjrZXw9w5HJB8wMUq",
	"N184tHrif/nRppy8HH08GyVYkQUXlMiz0Uv08WyU4YTon2cWiLPRGJ2N5j5npv0uJ5ckN4+NpeFsdKOf",
	"m3tSoFtU9fvxbLTItSIGb57phrJkwaO9m/aAH89GgsCvH29qQ348GxWU6V+7+nmBP+jfP/10c3NjNslQ",
	"1aqOo+8wNNLvvc7bo6BLDV1sU/6GKTPKQyny0cvRUqmVfLmjucdEgy8JnlC+M4pIc6921L+0GoF80uri",
	"/Ob/BQAA//+liQ1vY3UBAA==",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
